---
phase: 02-carddav-client-validation-gate
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/mailroom/core/config.py
  - src/mailroom/clients/carddav.py
  - tests/test_carddav_client.py
  - pyproject.toml
autonomous: true
requirements:
  - CDAV-01

must_haves:
  truths:
    - "CardDAV client authenticates with Fastmail using Basic auth (email + app password)"
    - "CardDAV client discovers the default address book URL via PROPFIND chain"
    - "All configured contact groups are validated at startup -- missing groups raise ValueError"
    - "Config includes carddav_username as a required field for Phase 2"
  artifacts:
    - path: "src/mailroom/clients/carddav.py"
      provides: "CardDAV client with connect(), validate_groups(), and XML parsing"
      exports: ["CardDAVClient"]
    - path: "src/mailroom/core/config.py"
      provides: "carddav_username config field and contact_groups property"
      contains: "carddav_username"
    - path: "tests/test_carddav_client.py"
      provides: "Unit tests for connection, discovery, group validation"
      min_lines: 80
    - path: "pyproject.toml"
      provides: "vobject dependency"
      contains: "vobject"
  key_links:
    - from: "src/mailroom/clients/carddav.py"
      to: "httpx.BasicAuth"
      via: "constructor authentication setup"
      pattern: "httpx\\.BasicAuth"
    - from: "src/mailroom/clients/carddav.py"
      to: "xml.etree.ElementTree"
      via: "PROPFIND response parsing"
      pattern: "ET\\.fromstring"
    - from: "src/mailroom/core/config.py"
      to: "src/mailroom/clients/carddav.py"
      via: "carddav_username and carddav_password fed to CardDAVClient constructor"
      pattern: "carddav_username"
---

<objective>
Build the CardDAV client foundation: config changes, Basic auth connection, PROPFIND address book discovery, and contact group validation at startup.

Purpose: CDAV-01 is the foundation for all contact operations. The PROPFIND discovery chain and group validation must work before search/create/update operations can be built. This also validates the Fastmail CardDAV endpoint and Apple-style group model assumptions.

Output: A working CardDAVClient class that can connect, discover the address book, and validate that required contact groups exist. Config updated with carddav_username.
</objective>

<execution_context>
@/Users/flo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/flo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-carddav-client-validation-gate/02-RESEARCH.md
@src/mailroom/core/config.py
@src/mailroom/clients/jmap.py
@tests/test_jmap_client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Config update and CardDAV client scaffold with connection tests</name>
  <files>
    src/mailroom/core/config.py
    src/mailroom/clients/carddav.py
    tests/test_carddav_client.py
    pyproject.toml
  </files>
  <action>
**RED phase:**

1. Add `vobject` dependency: run `uv add vobject` to add to pyproject.toml.

2. Update `src/mailroom/core/config.py`:
   - Add `carddav_username: str = ""` field (same empty-default pattern as carddav_password -- both become required when CardDAV is used, but empty defaults let Phase 1 tests pass without them).
   - Add `label_mailroom_error: str = "@MailroomError"` field for the error label (per user decision: verified at startup alongside other labels).
   - Add a `contact_groups` property returning `[self.group_imbox, self.group_feed, self.group_paper_trail, self.group_jail]` for startup validation.

3. Create `tests/test_carddav_client.py` with failing tests:
   - `test_connect_discovers_addressbook`: Mock the 3-step PROPFIND chain (principal -> home -> addressbook). Assert `client._addressbook_url` is set to the discovered URL.
   - `test_connect_auth_failure`: Mock a 401 response on the first PROPFIND. Assert `httpx.HTTPStatusError` is raised.
   - `test_connect_sets_addressbook_url`: After successful connect, assert the addressbook URL matches the parsed PROPFIND response.
   - `test_not_connected_guard`: Before connect(), accessing operations raises `RuntimeError` with "not connected" message (same pattern as JMAPClient).

**GREEN phase:**

4. Create `src/mailroom/clients/carddav.py` with `CardDAVClient` class:
   - Constructor takes `username: str, password: str, hostname: str = "carddav.fastmail.com"`.
   - Create `httpx.Client` with `httpx.BasicAuth(username, password)` and default `Content-Type: application/xml; charset=utf-8`.
   - Store `_addressbook_url: str | None = None`.
   - Implement `connect()` with 3-step PROPFIND discovery:
     - Step 1: PROPFIND `/` with `Depth: 0` for `current-user-principal`. Parse 207 Multi-Status XML response to extract principal URL.
     - Step 2: PROPFIND `{principal_url}` with `Depth: 0` for `addressbook-home-set`. Parse to extract home URL.
     - Step 3: PROPFIND `{home_url}` with `Depth: 1` for `resourcetype` and `displayname`. Find the child resource whose `resourcetype` contains `addressbook`. Set `_addressbook_url`.
   - Implement `_parse_multistatus()` helper for 207 XML parsing. Use Clark notation: `{DAV:}response`, `{DAV:}href`, `{DAV:}propstat`, `{DAV:}prop`, `{DAV:}status`, `{urn:ietf:params:xml:ns:carddav}address-data`. Define namespace constants at module level.
   - Connection guard: raise `RuntimeError("CardDAVClient is not connected. Call connect() first.")` if `_addressbook_url` is None when operations are called (same pattern as JMAPClient).

Run tests. All should pass.

**Important:** Use `xml.etree.ElementTree` for XML parsing (stdlib, not lxml). Use `httpx.BasicAuth` for authentication (not manual base64). Follow the JMAPClient pattern for class structure (constructor, connect, guard).
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run pytest tests/test_carddav_client.py -x -v</automated>
  </verify>
  <done>CardDAVClient connects via 3-step PROPFIND, discovers addressbook URL, raises on auth failure, guards against pre-connect access. Config has carddav_username and contact_groups. vobject is installed.</done>
</task>

<task type="auto">
  <name>Task 2: Group validation with TDD</name>
  <files>
    src/mailroom/clients/carddav.py
    tests/test_carddav_client.py
  </files>
  <action>
**RED phase:**

1. Add failing tests to `tests/test_carddav_client.py`:
   - `test_validate_groups_finds_all_groups`: Mock a PROPFIND response that lists all vCards, then mock individual GET responses for group vCards containing `X-ADDRESSBOOKSERVER-KIND:group`. Assert `validate_groups(["Imbox", "Feed", "Paper Trail", "Jail"])` returns a dict mapping each name to `{"href": ..., "etag": ..., "uid": ...}`.
   - `test_validate_groups_missing_group_raises`: Mock response with only 3 of 4 required groups. Assert `ValueError` is raised with the missing group name in the message.
   - `test_validate_groups_ignores_non_group_vcards`: Include regular contact vCards (without KIND:group) in the response. Assert they are filtered out and don't appear in the result.

**GREEN phase:**

2. Implement `validate_groups()` on `CardDAVClient`:
   - Takes `required_groups: list[str]` parameter.
   - Uses a PROPFIND or REPORT to fetch all vCards from the addressbook (PROPFIND with `Depth: 1` requesting `getetag` and `address-data` with `content-type` parameter for vCard, or a simpler REPORT requesting all entries).
   - For efficiency: use PROPFIND with `Depth: 1` to get `getetag` and `resourcetype` for all items in the addressbook, then GET each `.vcf` resource to fetch the full vCard. OR use a REPORT with `addressbook-query` without a filter to get all vCards with their data in one request.
   - Recommended approach: Use REPORT `addressbook-query` with no filter (returns all vCards), requesting `getetag` and `address-data` properties. This is a single round-trip.
   - Parse each returned vCard with `vobject.readOne()`.
   - Check for `X-ADDRESSBOOKSERVER-KIND:group` using `card.contents.get("x-addressbookserver-kind")` (vobject normalizes to lowercase with underscores, but `contents` dict uses the original lowercased-hyphenated key).
   - Match group FN against `required_groups`.
   - Return `{name: {"href": href, "etag": etag, "uid": card.uid.value}}` for matching groups.
   - Raise `ValueError` listing missing groups if any are not found: `"Required contact groups not found in Fastmail: {names}. Create them in Fastmail Contacts before starting Mailroom."`.
   - Store validated groups in `self._groups: dict[str, dict]` for later use by add_to_group().

Run tests. All should pass.

**Important:** Use `vobject.readOne()` for vCard parsing. Check property access patterns carefully -- vobject's `contents` dict uses lowercase hyphenated keys (e.g., `x-addressbookserver-kind`), while attribute access uses lowercase underscored names. Test both approaches and use the one that works.
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run pytest tests/test_carddav_client.py -x -v</automated>
  </verify>
  <done>validate_groups() fetches all group vCards, matches by FN, returns href/etag/uid map, raises ValueError with missing group names. Groups stored for later use.</done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/test_carddav_client.py -x -v` -- all tests pass
2. `uv run pytest tests/ -x` -- all existing tests still pass (no regressions)
3. `uv run ruff check src/ tests/` -- no lint errors
4. Config has `carddav_username`, `label_mailroom_error`, and `contact_groups` property
5. CardDAVClient has `connect()`, `validate_groups()`, and connection guard
6. `vobject` is in pyproject.toml dependencies
</verification>

<success_criteria>
- CardDAVClient authenticates and discovers the address book via PROPFIND
- Group validation correctly identifies Apple-style KIND:group vCards
- Missing groups produce clear error messages
- All unit tests pass with mocked httpx responses
- Config changes are backward-compatible (empty defaults)
</success_criteria>

<output>
After completion, create `.planning/phases/02-carddav-client-validation-gate/02-01-SUMMARY.md`
</output>

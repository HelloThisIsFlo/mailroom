---
phase: 08-eventsource-push
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/mailroom/core/config.py
  - src/mailroom/clients/jmap.py
  - src/mailroom/eventsource.py
  - tests/test_config.py
  - tests/test_jmap_client.py
  - tests/test_eventsource.py
autonomous: true
requirements: [PUSH-01, PUSH-02, PUSH-03, PUSH-04]

must_haves:
  truths:
    - "JMAPClient stores eventSourceUrl from session and exposes it as a property"
    - "MAILROOM_DEBOUNCE_SECONDS config field defaults to 3"
    - "MAILROOM_POLL_INTERVAL default is lowered from 300 to 60"
    - "SSE listener connects with Bearer auth and pushes state_changed signals to a queue on event: state lines"
    - "SSE listener reconnects with exponential backoff (1s->2s->4s->...->60s cap) on disconnect"
    - "SSE listener honors server retry: field when present"
    - "SSE listener detects dead connections via httpx read timeout (90s) exceeding 2x ping interval (30s)"
    - "Debounce drain helper empties a queue and returns the count"
  artifacts:
    - path: "src/mailroom/eventsource.py"
      provides: "SSE listener function, drain_queue helper"
      exports: ["sse_listener", "drain_queue"]
    - path: "src/mailroom/core/config.py"
      provides: "debounce_seconds field, lowered poll_interval default"
      contains: "debounce_seconds"
    - path: "src/mailroom/clients/jmap.py"
      provides: "event_source_url property from session"
      contains: "event_source_url"
    - path: "tests/test_eventsource.py"
      provides: "Unit tests for SSE listener, debounce, backoff, liveness"
  key_links:
    - from: "src/mailroom/eventsource.py"
      to: "queue.Queue"
      via: "event_queue.put('state_changed')"
      pattern: "event_queue\\.put"
    - from: "src/mailroom/clients/jmap.py"
      to: "JMAP session response"
      via: "data.get('eventSourceUrl')"
      pattern: "eventSourceUrl"
---

<objective>
TDD the core EventSource components: SSE listener function with reconnection logic, debounce helpers, config additions, and JMAPClient eventSourceUrl storage.

Purpose: These are the testable building blocks that Plan 02 will wire into the main loop. Each component has clear inputs and outputs suitable for RED-GREEN-REFACTOR cycles.

Output: `eventsource.py` module with SSE listener and drain helper, config changes for debounce_seconds and poll_interval, JMAPClient.event_source_url property, comprehensive unit tests.
</objective>

<execution_context>
@/Users/flo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/flo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-eventsource-push/08-CONTEXT.md
@.planning/phases/08-eventsource-push/08-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. -->

From src/mailroom/core/config.py:
```python
class MailroomSettings(BaseSettings):
    model_config = SettingsConfigDict(env_prefix="MAILROOM_", case_sensitive=False, arbitrary_types_allowed=True)
    jmap_token: str
    carddav_username: str = ""
    carddav_password: str = ""
    poll_interval: int = 300  # CHANGE to 60
    log_level: str = "info"
    # ... other fields ...
    # ADD: debounce_seconds: int = 3
```

From src/mailroom/clients/jmap.py:
```python
class JMAPClient:
    def __init__(self, token: str, hostname: str = "api.fastmail.com") -> None:
        self._token = token
        self._hostname = hostname
        self._http = httpx.Client(headers={...})
        self._api_url: str | None = None
        self._account_id: str | None = None
        self._session_capabilities: dict = {}
        self._download_url: str | None = None
        # ADD: self._event_source_url: str | None = None

    def connect(self) -> None:
        # Currently stores: _account_id, _api_url, _session_capabilities, _download_url
        # ADD: self._event_source_url = data.get("eventSourceUrl")

    @property
    def account_id(self) -> str: ...
    @property
    def session_capabilities(self) -> dict: ...
    # ADD: @property event_source_url -> str | None
```

From src/mailroom/__main__.py:
```python
class HealthHandler(BaseHTTPRequestHandler):
    last_successful_poll: float = 0.0
    poll_interval: int = 300
    # Plan 02 will add SSE fields here
```

From tests/test_jmap_client.py:
```python
FASTMAIL_SESSION_RESPONSE = {
    "apiUrl": "https://api.fastmail.com/jmap/api/",
    "primaryAccounts": {"urn:ietf:params:jmap:mail": "u1234", ...},
    "accounts": {"u1234": {"name": "user@fastmail.com"}},
    "capabilities": {},
    # NOTE: does NOT include eventSourceUrl -- needs update
}
```

Testing SSE streams (from 08-RESEARCH.md):
```python
from pytest_httpx import HTTPXMock, IteratorStream

# Mock SSE stream:
httpx_mock.add_response(
    url="...",
    stream=IteratorStream([b"event: state\n", b"data: {...}\n", b"\n"]),
    headers={"content-type": "text/event-stream"},
)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Config additions and JMAPClient eventSourceUrl</name>
  <files>src/mailroom/core/config.py, src/mailroom/clients/jmap.py, tests/test_config.py, tests/test_jmap_client.py</files>
  <action>
**RED phase -- write failing tests first:**

1. In `tests/test_config.py`, add two tests:

   a. `test_debounce_seconds_default` -- Create settings with just MAILROOM_JMAP_TOKEN, assert `settings.debounce_seconds == 3`.

   b. `test_poll_interval_default_lowered` -- Create settings with just MAILROOM_JMAP_TOKEN, assert `settings.poll_interval == 60`. NOTE: The existing `test_defaults` test asserts `poll_interval == 300` -- this test MUST be updated to assert 60 instead.

   c. `test_debounce_seconds_custom` -- Set `MAILROOM_DEBOUNCE_SECONDS=5` env var, create settings, assert `settings.debounce_seconds == 5`.

2. In `tests/test_jmap_client.py`:

   a. Update `FASTMAIL_SESSION_RESPONSE` fixture to include `"eventSourceUrl": "https://api.fastmail.com/jmap/event/"`.

   b. Add `test_connect_stores_event_source_url` in `TestConnect` class: Mock session endpoint with the updated fixture. After `client.connect()`, assert `client.event_source_url == "https://api.fastmail.com/jmap/event/"`.

   c. Add `test_event_source_url_none_when_missing`: Mock session endpoint WITHOUT eventSourceUrl in response. After `client.connect()`, assert `client.event_source_url is None`.

   d. Add `test_event_source_url_before_connect`: Assert `client.event_source_url is None` without calling connect().

Run tests -- they must FAIL (property/field doesn't exist yet).

**GREEN phase -- implement minimally:**

3. In `src/mailroom/core/config.py`, in `MailroomSettings`:
   - Change `poll_interval: int = 300` to `poll_interval: int = 60`
   - Add `debounce_seconds: int = 3` field (after poll_interval)

4. In `src/mailroom/clients/jmap.py`:
   - In `__init__`, add `self._event_source_url: str | None = None`
   - In `connect()`, after `self._download_url = data.get("downloadUrl")`, add `self._event_source_url = data.get("eventSourceUrl")`
   - Add property:
     ```python
     @property
     def event_source_url(self) -> str | None:
         """Return the EventSource URL from the JMAP session, or None."""
         return self._event_source_url
     ```

5. Update the existing `test_defaults` test in `tests/test_config.py` to assert `settings.poll_interval == 60` (was 300).

Run tests -- they must PASS.
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run pytest tests/test_config.py tests/test_jmap_client.py -x -v</automated>
  </verify>
  <done>
    - MailroomSettings.debounce_seconds defaults to 3, configurable via MAILROOM_DEBOUNCE_SECONDS
    - MailroomSettings.poll_interval default changed from 300 to 60
    - JMAPClient.event_source_url property returns URL from session or None
    - All existing and new tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: TDD SSE listener function with reconnection and debounce helpers</name>
  <files>src/mailroom/eventsource.py, tests/test_eventsource.py</files>
  <action>
**RED phase -- write failing tests first:**

1. Create `tests/test_eventsource.py` with the following test classes:

```python
"""Tests for EventSource SSE listener and debounce helpers."""

import queue
import threading
import time

import httpx
import pytest
from pytest_httpx import HTTPXMock, IteratorStream

from mailroom.eventsource import sse_listener, drain_queue
```

   a. **TestDrainQueue class:**
   - `test_drain_empty_queue`: Empty queue returns 0.
   - `test_drain_queue_with_items`: Put 3 items, drain returns 3, queue is now empty.
   - `test_drain_queue_partial`: Put 2 items, get 1 manually, drain returns 1.

   b. **TestSSEListener class:**
   - `test_sse_state_event_pushes_to_queue`: Mock SSE stream returning `event: state\ndata: {...}\n\n`. Run `sse_listener` in a thread (set shutdown_event after a short delay). Assert queue has at least 1 item ("state_changed").
   - `test_sse_ignores_ping_lines`: Mock SSE stream returning `: keepalive\nevent: state\ndata: {}\n\n`. Run listener. Assert queue has exactly 1 item (the state event, not the ping).
   - `test_sse_multiple_events`: Mock SSE stream returning two `event: state` blocks. Assert queue has 2 items.
   - `test_sse_auth_header`: Mock SSE stream (can be empty/short). Verify the request had `Authorization: Bearer test-token` and `Accept: text/event-stream` headers.
   - `test_sse_url_construction`: Mock SSE stream. Verify the request URL was `{event_source_url}?types=Email,Mailbox&closeafter=no&ping=30`.
   - `test_sse_reconnects_on_error`: Use httpx_mock to return a 500 error, then a successful stream. Set shutdown_event after brief delay. Assert queue eventually gets an item from the successful stream. Verify at least 2 requests were made.
   - `test_sse_exponential_backoff_caps_at_60`: This is a unit test on the backoff calculation. Verify that for attempt=7 (2^7=128), the delay is capped at 60. Test the formula directly: `min(2 ** attempt, 60)` for attempts 1-10.
   - `test_sse_honors_retry_field`: Mock SSE stream returning `retry: 5000\nevent: state\ndata: {}\n\n`. Run listener. Assert queue gets the state event. (The retry field storage is for reconnection -- verify the listener parses it without error.)
   - `test_sse_shutdown_event_stops_listener`: Set shutdown_event immediately. Run listener in thread. Assert thread completes within 2 seconds (clean exit).
   - `test_sse_read_timeout_triggers_reconnect`: Mock SSE with a stream that hangs (e.g., IteratorStream with a single line and long delay). Configure httpx timeout appropriately. Verify reconnection behavior.

   **Function signature for sse_listener:**
   ```python
   def sse_listener(
       token: str,
       event_source_url: str,
       event_queue: queue.Queue,
       shutdown_event: threading.Event,
       log,  # structlog.BoundLogger
   ) -> None:
   ```

   Note: The listener function tracks health status internally -- Plan 02 will add health handler integration. For now, the function signature does NOT include health. Plan 02 will add a health_status dict parameter.

Run tests -- they must FAIL (module doesn't exist).

**GREEN phase -- implement:**

2. Create `src/mailroom/eventsource.py`:

```python
"""JMAP EventSource (SSE) listener for push-triggered triage.

Architecture: The SSE listener runs in a daemon thread, pushes lightweight
"state_changed" signals to a queue.Queue. It never calls the workflow
directly -- it only signals that something changed. The main thread owns
all poll() calls.
"""

import queue
import threading
import time

import httpx
import structlog


def drain_queue(q: queue.Queue) -> int:
    """Drain all pending items from queue. Returns count drained."""
    count = 0
    while True:
        try:
            q.get_nowait()
            count += 1
        except queue.Empty:
            return count


def sse_listener(
    token: str,
    event_source_url: str,
    event_queue: queue.Queue,
    shutdown_event: threading.Event,
    log: structlog.BoundLogger | None = None,
) -> None:
    """Listen for JMAP EventSource events, push signals to queue.

    Connects to the Fastmail EventSource endpoint with Bearer auth,
    subscribes to Email and Mailbox state changes, and pushes
    "state_changed" signals to the event_queue on each state event.

    Reconnects with exponential backoff on disconnect (1s->2s->4s->...->60s cap).
    Honors server retry: field when present. Detects dead connections via
    httpx read timeout (90s > 2x 30s ping interval).

    Args:
        token: Fastmail API token for Bearer auth.
        event_source_url: Base EventSource URL from JMAP session.
        event_queue: Queue to push "state_changed" signals to.
        shutdown_event: Event to signal graceful shutdown.
        log: Structured logger instance.
    """
    if log is None:
        log = structlog.get_logger(component="eventsource")

    url = f"{event_source_url}?types=Email,Mailbox&closeafter=no&ping=30"
    attempt = 0
    server_retry_ms: int | None = None  # from retry: field

    while not shutdown_event.is_set():
        try:
            with httpx.Client(
                timeout=httpx.Timeout(connect=30.0, read=90.0, write=30.0, pool=30.0)
            ) as http:
                with http.stream(
                    "GET",
                    url,
                    headers={
                        "Authorization": f"Bearer {token}",
                        "Accept": "text/event-stream",
                    },
                ) as response:
                    response.raise_for_status()
                    attempt = 0  # reset on successful connect
                    server_retry_ms = None
                    log.info("eventsource_connected")

                    for line in response.iter_lines():
                        if shutdown_event.is_set():
                            return
                        if line.startswith("event: state"):
                            event_queue.put("state_changed")
                        elif line.startswith("retry:"):
                            # Honor server-suggested reconnection delay (milliseconds)
                            try:
                                server_retry_ms = int(line.split(":", 1)[1].strip())
                            except (ValueError, IndexError):
                                pass  # ignore malformed retry field

        except Exception as exc:
            if shutdown_event.is_set():
                return
            attempt += 1
            # Use server retry if available, otherwise exponential backoff
            if server_retry_ms is not None:
                delay = server_retry_ms / 1000.0
            else:
                delay = min(2 ** attempt, 60)
            log.warning(
                "eventsource_disconnected",
                retry_in=delay,
                attempt=attempt,
                error=str(exc),
            )
            shutdown_event.wait(delay)

    log.info("eventsource_stopped")
```

Run tests -- they must PASS.

**REFACTOR phase (if needed):** Clean up any test helpers, ensure docstrings are complete.

**Commit pattern:**
- RED: `test(08-01): add failing tests for SSE listener, drain_queue, config, and eventSourceUrl`
- GREEN: `feat(08-01): implement SSE listener, drain_queue, config changes, and eventSourceUrl`
- REFACTOR (if needed): `refactor(08-01): clean up eventsource module`
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run pytest tests/test_eventsource.py tests/test_config.py tests/test_jmap_client.py -x -v</automated>
  </verify>
  <done>
    - src/mailroom/eventsource.py exists with sse_listener() and drain_queue() functions
    - SSE listener connects to {eventSourceUrl}?types=Email,Mailbox&closeafter=no&ping=30 with Bearer auth
    - SSE listener pushes "state_changed" to queue on "event: state" lines
    - SSE listener ignores ping/comment lines (: prefix)
    - SSE listener reconnects with exponential backoff (1s->2s->4s->...->60s cap)
    - SSE listener honors server retry: field when present
    - SSE listener uses httpx read timeout of 90s (> 2x 30s ping interval)
    - SSE listener respects shutdown_event for clean exit
    - drain_queue() empties queue and returns count
    - All tests pass including existing test suite
  </done>
</task>

</tasks>

<verification>
```bash
# All unit tests pass (existing + new)
cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run pytest tests/ -x -v

# Config changes verified
uv run python -c "import os; os.environ['MAILROOM_JMAP_TOKEN']='x'; from mailroom.core.config import MailroomSettings; s=MailroomSettings(); print(f'poll_interval={s.poll_interval}, debounce_seconds={s.debounce_seconds}')"
# Expected output: poll_interval=60, debounce_seconds=3

# eventSourceUrl property exists
uv run python -c "from mailroom.clients.jmap import JMAPClient; c=JMAPClient(token='x'); print(f'event_source_url={c.event_source_url}')"
# Expected output: event_source_url=None

# eventsource module imports cleanly
uv run python -c "from mailroom.eventsource import sse_listener, drain_queue; print('OK')"
```
</verification>

<success_criteria>
- MailroomSettings.debounce_seconds = 3 (configurable via MAILROOM_DEBOUNCE_SECONDS)
- MailroomSettings.poll_interval default = 60 (changed from 300)
- JMAPClient.event_source_url property returns URL from session or None
- SSE listener function handles connection, state events, pings, reconnection, backoff, and shutdown
- drain_queue helper drains a queue and returns count
- Comprehensive unit tests cover all behaviors
- Full existing test suite continues to pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-eventsource-push/08-01-SUMMARY.md`
</output>

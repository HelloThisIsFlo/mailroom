---
phase: 08-eventsource-push
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/mailroom/__main__.py
  - src/mailroom/eventsource.py
  - tests/test_eventsource.py
  - human-tests/test_16_eventsource_push.py
autonomous: true
requirements: [PUSH-02, PUSH-04, PUSH-06]
gap_closure: true

must_haves:
  truths:
    - "Service shuts down within 1 second of SIGINT/SIGTERM, not up to 60 seconds"
    - "Health endpoint /healthz includes last_poll_trigger field showing push or fallback"
    - "Human test 16 detects discrete poll events by timestamp change and reports trigger type"
    - "SSE reconnection unit tests complete in under 0.5 seconds each, not 2+ seconds"
  artifacts:
    - path: "src/mailroom/__main__.py"
      provides: "Sentinel-based shutdown wakeup, last_poll_trigger in health JSON"
      contains: "last_poll_trigger"
    - path: "src/mailroom/eventsource.py"
      provides: "Injectable sleep_fn for testable backoff"
      contains: "sleep_fn"
    - path: "tests/test_eventsource.py"
      provides: "Fast backoff tests using injected sleep_fn"
    - path: "human-tests/test_16_eventsource_push.py"
      provides: "Discrete event detection via timestamp + trigger field"
  key_links:
    - from: "src/mailroom/__main__.py"
      to: "queue.Queue"
      via: "event_queue.put(None) in signal handler"
      pattern: "event_queue\\.put\\(None\\)"
    - from: "src/mailroom/__main__.py"
      to: "HealthHandler"
      via: "HealthHandler.last_poll_trigger = trigger"
      pattern: "last_poll_trigger"
    - from: "human-tests/test_16_eventsource_push.py"
      to: "/healthz"
      via: "reads last_poll_trigger from health JSON"
      pattern: "last_poll_trigger"
---

<objective>
Close three UAT gaps from Phase 08: prompt shutdown on signal, health endpoint trigger field for human test, and fast unit tests via injectable sleep.

Purpose: The UAT revealed a 15-second shutdown delay (queue.get blocks), a broken human test (no trigger field in /healthz, wrong monitoring approach), and 4 seconds of unnecessary real-time waits in two unit tests.

Output: All three issues fixed. Service shuts down in under 1 second. Human test 16 reliably detects push-triggered triage. SSE test suite runs ~4 seconds faster.
</objective>

<execution_context>
@/Users/flo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/flo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-eventsource-push/08-01-SUMMARY.md
@.planning/phases/08-eventsource-push/08-02-SUMMARY.md
@.planning/phases/08-eventsource-push/08-UAT.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/mailroom/__main__.py (lines 33-66):
```python
class HealthHandler(BaseHTTPRequestHandler):
    last_successful_poll: float = 0.0
    poll_interval: int = 300
    # EventSource status (written by SSE thread, read by health endpoint)
    sse_status: str = "not_started"
    sse_connected_since: float | None = None
    sse_last_event_at: float | None = None
    sse_reconnect_count: int = 0
    sse_last_error: str | None = None

    def do_GET(self) -> None:
        # builds JSON with "status", "last_poll_age_seconds", "eventsource" object
```

From src/mailroom/__main__.py (lines 128-189) - signal handler and main loop:
```python
shutdown_event = threading.Event()
event_queue: queue.Queue = queue.Queue()

def _handle_signal(signum, frame):
    log.info("shutdown_signal_received", signal=signum)
    shutdown_event.set()

# Main loop:
while not shutdown_event.is_set():
    trigger = "fallback"
    try:
        event_queue.get(timeout=settings.poll_interval)  # blocks up to 60s
        # ... drain, debounce, set trigger = "push"
    except queue.Empty:
        pass
    if shutdown_event.is_set():
        break
    # ... workflow.poll(), HealthHandler.last_successful_poll = time.time()
```

From src/mailroom/eventsource.py (lines 30-37):
```python
def sse_listener(
    token: str,
    event_source_url: str,
    event_queue: queue.Queue,
    shutdown_event: threading.Event,
    log: structlog.BoundLogger | None = None,
    health_cls: type | None = None,
) -> None:
```

Backoff delay at eventsource.py line 117:
```python
shutdown_event.wait(delay)  # This is the sleep that blocks tests
```

From tests/test_eventsource.py:
```python
class MockHealthHandler:
    sse_status, sse_connected_since, sse_last_event_at, sse_reconnect_count, sse_last_error
    @classmethod def reset(cls): ...
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Prompt shutdown via queue sentinel and injectable sleep_fn</name>
  <files>
    src/mailroom/__main__.py
    src/mailroom/eventsource.py
  </files>
  <action>
Two changes to production code:

**1. Prompt shutdown in __main__.py (Gap 1):**

The signal handler currently only sets `shutdown_event.set()`, but `queue.get(timeout=poll_interval)` at line 175 blocks up to 60s and only checks shutdown after it returns. Fix:

- Move `event_queue` creation BEFORE the signal handler definition (it is already above it at line 139, so this is fine)
- In `_handle_signal`, after `shutdown_event.set()`, add `event_queue.put(None)` to unblock the queue.get() call immediately
- In the main loop, after `event_queue.get(timeout=settings.poll_interval)` succeeds (line 175), add a guard: `if shutdown_event.is_set(): break` BEFORE the drain/debounce logic. This catches the None sentinel and exits immediately.

The existing `if shutdown_event.is_set(): break` at line 188-189 already handles the post-debounce case, but we need the early exit before drain_queue and debounce_seconds wait.

**2. Injectable sleep_fn in eventsource.py (Gap 3):**

Add a `sleep_fn` parameter to `sse_listener()`:

```python
def sse_listener(
    token: str,
    event_source_url: str,
    event_queue: queue.Queue,
    shutdown_event: threading.Event,
    log: structlog.BoundLogger | None = None,
    health_cls: type | None = None,
    sleep_fn: Callable[[float], None] | None = None,
) -> None:
```

- Add `from typing import Callable` (or use `collections.abc.Callable`)
- Default: `if sleep_fn is None: sleep_fn = lambda delay: shutdown_event.wait(delay)`
- Replace `shutdown_event.wait(delay)` at line 117 with `sleep_fn(delay)`
- This is backward compatible: callers that don't pass sleep_fn get the same behavior

Do NOT change the `from __future__ import annotations` import at the top of eventsource.py -- it already exists.
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && python -m pytest tests/test_eventsource.py -x -q 2>&1 | tail -5</automated>
  </verify>
  <done>Signal handler pushes None sentinel to event_queue for instant shutdown wakeup. sse_listener accepts optional sleep_fn parameter. All existing tests still pass.</done>
</task>

<task type="auto">
  <name>Task 2: Add last_poll_trigger to health endpoint and speed up SSE tests</name>
  <files>
    src/mailroom/__main__.py
    tests/test_eventsource.py
  </files>
  <action>
**1. Health endpoint trigger field in __main__.py (Gap 2 server-side):**

Add a class-level attribute to HealthHandler:
```python
last_poll_trigger: str | None = None
```

In the main loop, after `workflow.poll()` succeeds (around line 194), alongside the existing `HealthHandler.last_successful_poll = time.time()`, add:
```python
HealthHandler.last_poll_trigger = trigger
```

In `do_GET`, add `last_poll_trigger` to the health JSON response at the top level (next to `last_poll_age_seconds`):
```python
"last_poll_trigger": self.last_poll_trigger,
```

**2. Speed up SSE backoff tests in tests/test_eventsource.py (Gap 3 test-side):**

Update `TestSSEListener._run_listener` to accept a `sleep_fn` keyword arg and pass it through:
```python
def _run_listener(self, event_queue, shutdown, **kwargs):
    sse_listener(
        token=kwargs.get("token", "test-token"),
        event_source_url="https://api.fastmail.com/jmap/event/",
        event_queue=event_queue,
        shutdown_event=shutdown,
        log=None,
        sleep_fn=kwargs.get("sleep_fn"),
    )
```

Similarly update `TestHealthSSE._run_listener` to pass `sleep_fn`:
```python
def _run_listener(self, event_queue, shutdown, health_cls=None, **kwargs):
    sse_listener(
        token=kwargs.get("token", "test-token"),
        event_source_url="https://api.fastmail.com/jmap/event/",
        event_queue=event_queue,
        shutdown_event=shutdown,
        log=None,
        health_cls=health_cls,
        sleep_fn=kwargs.get("sleep_fn"),
    )
```

In `test_sse_reconnects_on_error`: pass `sleep_fn=lambda t: None` via kwargs to skip the 2s real wait. The thread call becomes:
```python
t = threading.Thread(
    target=self._run_listener,
    args=(event_queue, shutdown),
    kwargs={"sleep_fn": lambda t: None},
)
```

In `TestHealthSSE.test_sse_updates_health_on_disconnect`: pass `sleep_fn=lambda t: None` via kwargs:
```python
t = threading.Thread(
    target=self._run_listener,
    args=(event_queue, shutdown),
    kwargs={"health_cls": MockHealthHandler, "sleep_fn": lambda t: None},
)
```

These two tests should now complete in under 0.1s each instead of 2s.
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && python -m pytest tests/test_eventsource.py -x -q --durations=3 2>&1 | tail -10</automated>
  </verify>
  <done>Health JSON includes last_poll_trigger field. Two slow tests (test_sse_reconnects_on_error, test_sse_updates_health_on_disconnect) each complete in under 0.5 seconds. Full test_eventsource.py suite runs in under 1 second total.</done>
</task>

<task type="auto">
  <name>Task 3: Rewrite human test 16 with discrete event detection</name>
  <files>
    human-tests/test_16_eventsource_push.py
  </files>
  <action>
Rewrite the monitoring loop in Step 4 of test_16_eventsource_push.py to detect discrete poll events and report trigger type. The current implementation checks `last_poll_age_seconds < 5` which fires on every 2-second check within that window, producing a stream of "POLL DETECTED" lines with no useful information.

**New monitoring approach:**

Track `last_successful_poll` timestamp (via `last_poll_age_seconds` changes) to detect when a NEW poll happens. Read `last_poll_trigger` from the health JSON to report whether it was push or fallback.

Replace the Step 4 monitoring loop with:

```python
# Step 4: Automated monitoring loop
print("4. Automated monitoring (press Ctrl+C to stop):")
print("   Watching for new poll events via /healthz...")
print("   Apply a triage label now and watch for PUSH events.")
print()

try:
    prev_age: float | None = None
    poll_count = 0
    while True:
        try:
            health_resp = httpx.get(
                "http://localhost:8080/healthz", timeout=5.0
            )
            health = health_resp.json()
            age = health.get("last_poll_age_seconds", 0)
            trigger = health.get("last_poll_trigger", "unknown")
            sse = health.get("eventsource", {})

            # Detect a new poll: age decreased (timestamp jumped forward)
            if prev_age is not None and age < prev_age - 1:
                poll_count += 1
                label = "PUSH" if trigger == "push" else "FALLBACK"
                print(
                    f"   [{label}] Poll #{poll_count} detected "
                    f"(age: {age:.1f}s, trigger: {trigger}, "
                    f"SSE: {sse.get('status')})"
                )
                if trigger == "push":
                    print(f"         ^ Push-triggered triage confirmed!")

            prev_age = age
        except Exception:
            pass
        time.sleep(1)
except KeyboardInterrupt:
    print(f"\n   Monitoring stopped. {poll_count} poll(s) detected.")
```

Key changes from the original:
1. Detect NEW polls by watching for age to DROP (meaning last_successful_poll timestamp advanced). The `age < prev_age - 1` guard means age went from e.g. 12s back down to 0.5s -- a new poll happened.
2. Read `last_poll_trigger` from health JSON to report push vs fallback.
3. Poll every 1 second instead of 2 for more responsive detection.
4. Count total polls and report at the end.
5. Clear labeling: `[PUSH]` vs `[FALLBACK]` prefix on each detected poll.

Also update the docstring to reflect the improved monitoring.

Keep Steps 1-3 exactly as they are (JMAP session check, health endpoint check, manual instructions). Only replace Step 4.
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && python -c "import ast; ast.parse(open('human-tests/test_16_eventsource_push.py').read()); print('syntax OK')"</automated>
  </verify>
  <done>Human test 16 detects discrete poll events by timestamp change (age drop), reports [PUSH] or [FALLBACK] with trigger field, and no longer produces a stream of redundant "POLL DETECTED" lines.</done>
</task>

</tasks>

<verification>
1. All 276+ existing tests pass: `python -m pytest -x -q`
2. SSE tests specifically: `python -m pytest tests/test_eventsource.py -v --durations=5` -- no test over 0.5s
3. Human test 16 has valid syntax and imports
4. Health endpoint JSON includes `last_poll_trigger` field
</verification>

<success_criteria>
- Service responds to SIGINT within 1 second (sentinel unblocks queue.get immediately)
- /healthz JSON includes `last_poll_trigger` field (null before first poll, then "push" or "fallback")
- test_sse_reconnects_on_error completes in <0.5s (was 2.03s)
- test_sse_updates_health_on_disconnect completes in <0.5s (was 2.03s)
- Human test 16 monitoring detects discrete poll events and distinguishes push from fallback triggers
</success_criteria>

<output>
After completion, create `.planning/phases/08-eventsource-push/08-03-SUMMARY.md`
</output>

---
phase: 08-eventsource-push
plan: 02
type: execute
wave: 2
depends_on: [08-01]
files_modified:
  - src/mailroom/__main__.py
  - src/mailroom/eventsource.py
  - tests/test_eventsource.py
  - human-tests/test_16_eventsource_push.py
autonomous: true
requirements: [PUSH-05, PUSH-06]

must_haves:
  truths:
    - "Main loop uses queue.get(timeout=poll_interval) for combined event-driven wake and fallback polling"
    - "SSE state events trigger poll within debounce_seconds, not poll_interval"
    - "If SSE connection drops, service continues polling at poll_interval (triage never stops)"
    - "Poll log entries include trigger source: trigger=push or trigger=fallback"
    - "Health endpoint reports EventSource status object: status, connected_since, last_event_at, reconnect_count, last_error"
    - "Service startup logs include eventsource_listener_started when eventSourceUrl is available"
    - "Graceful shutdown (SIGTERM) cleanly stops SSE listener thread"
    - "Human integration test validates sub-10-second triage latency via push"
  artifacts:
    - path: "src/mailroom/__main__.py"
      provides: "Queue-based debounced main loop with SSE thread startup, health endpoint with SSE status"
      contains: "event_queue.get"
    - path: "src/mailroom/eventsource.py"
      provides: "Updated sse_listener with health status reporting"
      contains: "sse_status"
    - path: "human-tests/test_16_eventsource_push.py"
      provides: "End-to-end latency test for push-triggered triage"
  key_links:
    - from: "src/mailroom/__main__.py"
      to: "src/mailroom/eventsource.py"
      via: "sse_listener function called in daemon thread"
      pattern: "from mailroom\\.eventsource import"
    - from: "src/mailroom/__main__.py"
      to: "queue.Queue"
      via: "event_queue.get(timeout=settings.poll_interval)"
      pattern: "event_queue\\.get"
    - from: "src/mailroom/eventsource.py"
      to: "HealthHandler class attributes"
      via: "Direct class attribute assignment for SSE status"
      pattern: "HealthHandler\\.sse_"
---

<objective>
Wire the SSE listener into the main loop, add EventSource status to the health endpoint, include trigger source in poll logs, and create the human integration test for sub-10-second triage latency.

Purpose: This plan transforms the fixed-interval polling service into a push-triggered triage service. The core SSE components from Plan 01 are wired into the main loop, and the health endpoint is extended with SSE observability.

Output: Updated `__main__.py` with queue-based debounced main loop, health endpoint reporting SSE status, updated `eventsource.py` with health reporting, and human integration test.
</objective>

<execution_context>
@/Users/flo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/flo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-eventsource-push/08-CONTEXT.md
@.planning/phases/08-eventsource-push/08-RESEARCH.md
@.planning/phases/08-eventsource-push/08-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts from Plan 01 output -->

From src/mailroom/eventsource.py (created in Plan 01):
```python
def drain_queue(q: queue.Queue) -> int:
    """Drain all pending items from queue. Returns count drained."""
    ...

def sse_listener(
    token: str,
    event_source_url: str,
    event_queue: queue.Queue,
    shutdown_event: threading.Event,
    log: structlog.BoundLogger | None = None,
) -> None:
    """Listen for JMAP EventSource events, push signals to queue.
    Reconnects with exponential backoff. Honors server retry: field.
    """
    ...
```

From src/mailroom/core/config.py (updated in Plan 01):
```python
class MailroomSettings(BaseSettings):
    poll_interval: int = 60   # lowered from 300
    debounce_seconds: int = 3  # EventSource debounce window
    # ... other fields unchanged ...
```

From src/mailroom/clients/jmap.py (updated in Plan 01):
```python
class JMAPClient:
    @property
    def event_source_url(self) -> str | None:
        """Return the EventSource URL from the JMAP session, or None."""
        return self._event_source_url
```

From src/mailroom/__main__.py (current):
```python
class HealthHandler(BaseHTTPRequestHandler):
    last_successful_poll: float = 0.0
    poll_interval: int = 300

    def do_GET(self) -> None:
        if self.path == "/healthz":
            age = time.time() - self.last_successful_poll
            healthy = self.last_successful_poll == 0.0 or age < (self.poll_interval * 2)
            status = 200 if healthy else 503
            body = json.dumps({
                "status": "ok" if healthy else "unhealthy",
                "last_poll_age_seconds": round(age, 1),
            })
            ...

def main() -> None:
    # 1-7: Startup sequence (config, jmap, carddav, mailboxes, groups, workflow, health)
    # Polling loop: while not shutdown_event.is_set(): workflow.poll(); shutdown_event.wait(poll_interval)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add health SSE status and update sse_listener for health reporting</name>
  <files>src/mailroom/__main__.py, src/mailroom/eventsource.py, tests/test_eventsource.py</files>
  <action>
1. **Extend HealthHandler with SSE status fields** in `src/mailroom/__main__.py`:

   Add class-level attributes after the existing ones:
   ```python
   class HealthHandler(BaseHTTPRequestHandler):
       last_successful_poll: float = 0.0
       poll_interval: int = 300
       # EventSource status (written by SSE thread, read by health endpoint)
       sse_status: str = "not_started"
       sse_connected_since: float | None = None
       sse_last_event_at: float | None = None
       sse_reconnect_count: int = 0
       sse_last_error: str | None = None
   ```

2. **Update the health endpoint response** in `HealthHandler.do_GET()`:

   Add the `eventsource` object to the JSON response body:
   ```python
   body = json.dumps({
       "status": "ok" if healthy else "unhealthy",
       "last_poll_age_seconds": round(age, 1),
       "eventsource": {
           "status": self.sse_status,
           "connected_since": self.sse_connected_since,
           "last_event_at": self.sse_last_event_at,
           "reconnect_count": self.sse_reconnect_count,
           "last_error": self.sse_last_error,
       },
   })
   ```

   Per user decision: poll staleness threshold remains at 2x poll_interval. SSE pings are keepalives, not state events -- quiet mailbox does not mean broken SSE. Overall health status is NOT degraded when SSE is down (only poll staleness matters for health).

3. **Update `sse_listener` signature** in `src/mailroom/eventsource.py` to accept a health status reporting mechanism:

   Rather than importing HealthHandler (would create circular import), pass a simple dict-like object or use a callback pattern. The cleanest approach: pass the HealthHandler class itself since it uses class-level attributes:

   Update the `sse_listener` function signature to accept a `health_cls` parameter (the HealthHandler class):
   ```python
   def sse_listener(
       token: str,
       event_source_url: str,
       event_queue: queue.Queue,
       shutdown_event: threading.Event,
       log: structlog.BoundLogger | None = None,
       health_cls: type | None = None,
   ) -> None:
   ```

   Add health status updates at key points in the function:
   - On successful connect: `health_cls.sse_status = "connected"`, `health_cls.sse_connected_since = time.time()`
   - On state event received: `health_cls.sse_last_event_at = time.time()`
   - On disconnect/error: `health_cls.sse_status = "disconnected"`, `health_cls.sse_reconnect_count += 1`, `health_cls.sse_last_error = str(exc)`

   Guard all health updates with `if health_cls is not None:` so the function works without health reporting (backward compatible with Plan 01 tests).

4. **Add tests** in `tests/test_eventsource.py`:

   a. **TestHealthSSE class:**
   - `test_sse_updates_health_on_connect`: Create a mock class with SSE health attributes. Run sse_listener with a successful mock stream and the health class. Assert `health_cls.sse_status == "connected"` and `health_cls.sse_connected_since` is set.
   - `test_sse_updates_health_on_event`: Run sse_listener with a state event stream. Assert `health_cls.sse_last_event_at` is set after event.
   - `test_sse_updates_health_on_disconnect`: Mock a failing SSE connection. Assert `health_cls.sse_status == "disconnected"` and `health_cls.sse_reconnect_count >= 1` and `health_cls.sse_last_error` is set.
   - `test_sse_works_without_health_cls`: Run sse_listener with `health_cls=None`. Assert no errors (backward compat with Plan 01 tests).

   For the mock health class, create a simple test helper:
   ```python
   class MockHealthHandler:
       sse_status: str = "not_started"
       sse_connected_since: float | None = None
       sse_last_event_at: float | None = None
       sse_reconnect_count: int = 0
       sse_last_error: str | None = None
   ```
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run pytest tests/test_eventsource.py -x -v</automated>
  </verify>
  <done>
    - HealthHandler has SSE status class-level attributes (sse_status, sse_connected_since, sse_last_event_at, sse_reconnect_count, sse_last_error)
    - Health endpoint /healthz returns eventsource object in JSON response
    - sse_listener updates health status on connect, event, and disconnect
    - sse_listener works without health_cls (backward compat)
    - All existing Plan 01 tests continue to pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace main loop with queue-based debounced loop and SSE thread startup</name>
  <files>src/mailroom/__main__.py</files>
  <action>
1. **Add imports** at the top of `src/mailroom/__main__.py`:
   ```python
   import queue
   from mailroom.eventsource import sse_listener, drain_queue
   ```

2. **Replace the polling loop** in `main()`. The current loop (lines ~123-142):
   ```python
   while not shutdown_event.is_set():
       try:
           workflow.poll()
           consecutive_failures = 0
           HealthHandler.last_successful_poll = time.time()
       except Exception:
           ...
       shutdown_event.wait(settings.poll_interval)
   ```

   Replace with the SSE-powered debounced loop:

   a. **After step 7 (health server start), before the polling loop**, add SSE thread startup:
   ```python
   # 8. Start EventSource listener thread (if available)
   event_queue: queue.Queue = queue.Queue()

   if jmap.event_source_url:
       sse_thread = threading.Thread(
           target=sse_listener,
           args=(
               settings.jmap_token,
               jmap.event_source_url,
               event_queue,
               shutdown_event,
           ),
           kwargs={
               "log": structlog.get_logger(component="eventsource"),
               "health_cls": HealthHandler,
           },
           daemon=True,
       )
       sse_thread.start()
       log.info("eventsource_listener_started", url=jmap.event_source_url)
   else:
       log.info("eventsource_not_available", reason="no eventSourceUrl in session")
   ```

   b. **Replace the main while loop** with the debounced version:
   ```python
   log.info(
       "service_started",
       poll_interval=settings.poll_interval,
       debounce_seconds=settings.debounce_seconds,
       health_port=HEALTH_PORT,
       push_enabled=jmap.event_source_url is not None,
   )
   consecutive_failures = 0

   while not shutdown_event.is_set():
       trigger = "fallback"
       try:
           event_queue.get(timeout=settings.poll_interval)
           # Got SSE event -- drain queue and debounce
           drain_queue(event_queue)
           shutdown_event.wait(settings.debounce_seconds)
           drain_queue(event_queue)  # drain arrivals during debounce
           trigger = "push"
       except queue.Empty:
           pass  # Fallback: no SSE event within poll_interval

       if shutdown_event.is_set():
           break

       try:
           workflow.poll()
           consecutive_failures = 0
           HealthHandler.last_successful_poll = time.time()
           log.info("poll_completed", trigger=trigger)
       except Exception:
           consecutive_failures += 1
           log.error(
               "poll_failed",
               consecutive_failures=consecutive_failures,
               trigger=trigger,
               exc_info=True,
           )
           if consecutive_failures >= MAX_CONSECUTIVE_FAILURES:
               log.critical(
                   "too_many_consecutive_failures",
                   threshold=MAX_CONSECUTIVE_FAILURES,
               )
               sys.exit(1)
   ```

   Key differences from old loop:
   - `shutdown_event.wait(settings.poll_interval)` replaced by `event_queue.get(timeout=settings.poll_interval)` -- combined event wait + fallback timer
   - Debounce window after SSE event: `shutdown_event.wait(settings.debounce_seconds)` (interruptible, not time.sleep)
   - `trigger` variable tracks "push" vs "fallback" for logging (user decision: poll log entries must include trigger source)
   - `log.info("poll_completed", trigger=trigger)` added after successful poll
   - Drain before and after debounce to collapse rapid events

3. **Debounce stats logging** (user decision: DEBUG level only):

   Add a debug log line after drain in the debounce window for collapse stats:
   ```python
   try:
       event_queue.get(timeout=settings.poll_interval)
       pre_drain = drain_queue(event_queue)
       shutdown_event.wait(settings.debounce_seconds)
       post_drain = drain_queue(event_queue)
       trigger = "push"
       log.debug(
           "debounce_collapsed",
           events_collapsed=1 + pre_drain + post_drain,
       )
   except queue.Empty:
       pass
   ```

4. **Graceful shutdown** -- the existing `_handle_signal` already sets `shutdown_event`. The SSE listener checks `shutdown_event.is_set()` in its loop. The daemon=True flag on the SSE thread ensures it doesn't block process exit. The queue.get() and shutdown_event.wait() calls are both interruptible. No changes needed to signal handling.
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run pytest tests/ -x -v</automated>
  </verify>
  <done>
    - Main loop uses event_queue.get(timeout=poll_interval) instead of shutdown_event.wait(poll_interval)
    - SSE state events trigger poll after debounce_seconds delay (not poll_interval)
    - Fallback polling continues at poll_interval when no SSE events arrive
    - Poll log entries include trigger="push" or trigger="fallback"
    - Debounce collapse stats logged at DEBUG level
    - SSE listener thread starts when eventSourceUrl is available
    - Graceful shutdown stops SSE thread cleanly
    - All existing tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Create human integration test for push-triggered triage latency</name>
  <files>human-tests/test_16_eventsource_push.py</files>
  <action>
Create `human-tests/test_16_eventsource_push.py` following the pattern of existing human tests (standalone scripts against real Fastmail):

```python
#!/usr/bin/env python3
"""Test 16: EventSource push-triggered triage latency.

Validates PUSH-06: triage latency under 10 seconds via push notification.

Prerequisites:
- Mailroom service running with EventSource push enabled
- Fastmail account with screener mailbox and triage labels configured
- A test sender email in the screener mailbox

Steps:
1. Connect to JMAP session and verify eventSourceUrl is available
2. Apply a triage label to a test email in the screener mailbox
3. Wait and observe: the service should triage the email within 10 seconds
4. Report the actual triage latency

Run: python human-tests/test_16_eventsource_push.py
"""

import os
import sys
import time

import httpx


def main():
    token = os.environ.get("MAILROOM_JMAP_TOKEN")
    if not token:
        print("ERROR: MAILROOM_JMAP_TOKEN not set")
        sys.exit(1)

    print("=" * 60)
    print("Test 16: EventSource Push-Triggered Triage Latency")
    print("=" * 60)

    # Step 1: Connect to JMAP session
    print("\n1. Connecting to JMAP session...")
    with httpx.Client() as http:
        resp = http.get(
            "https://api.fastmail.com/jmap/session",
            headers={"Authorization": f"Bearer {token}"},
        )
        resp.raise_for_status()
        session = resp.json()

    api_url = session["apiUrl"]
    account_id = session["primaryAccounts"]["urn:ietf:params:jmap:mail"]
    event_source_url = session.get("eventSourceUrl")

    print(f"   Account: {account_id}")
    print(f"   EventSource URL: {event_source_url or 'NOT AVAILABLE'}")

    if not event_source_url:
        print("\n   WARNING: No eventSourceUrl in session. Push not available.")
        print("   This test requires EventSource support.")
        sys.exit(1)

    # Step 2: Check health endpoint for SSE status
    print("\n2. Checking service health endpoint...")
    try:
        health_resp = httpx.get("http://localhost:8080/healthz", timeout=5.0)
        health = health_resp.json()
        print(f"   Service status: {health.get('status')}")
        sse_info = health.get("eventsource", {})
        print(f"   SSE status: {sse_info.get('status')}")
        print(f"   SSE connected since: {sse_info.get('connected_since')}")
        print(f"   SSE reconnect count: {sse_info.get('reconnect_count')}")
    except Exception as e:
        print(f"   WARNING: Could not reach health endpoint: {e}")
        print("   Make sure the Mailroom service is running.")

    # Step 3: Instructions for manual test
    print("\n3. Manual latency test:")
    print("   a. Open Fastmail on your phone")
    print("   b. Find an email in the Screener mailbox")
    print("   c. Apply a triage label (e.g., @ToFeed)")
    print("   d. Watch the service logs for 'poll_completed trigger=push'")
    print("   e. The triage should complete within 10 seconds")
    print()
    print("   Expected log output:")
    print('     {"event": "poll_completed", "trigger": "push", ...}')
    print()
    print("   If you see trigger=fallback, the SSE connection may not be working.")
    print()

    # Step 4: Optional automated timing loop
    print("4. Automated monitoring (press Ctrl+C to stop):")
    print("   Polling health endpoint every 2 seconds to detect triage activity...")
    print()

    try:
        last_poll_time = None
        while True:
            try:
                health_resp = httpx.get("http://localhost:8080/healthz", timeout=5.0)
                health = health_resp.json()
                age = health.get("last_poll_age_seconds", 0)
                sse = health.get("eventsource", {})

                # Detect a fresh poll (age resets)
                if age < 5 and last_poll_time != age:
                    print(f"   POLL DETECTED - age: {age}s, SSE: {sse.get('status')}")
                    last_poll_time = age
            except Exception:
                pass
            time.sleep(2)
    except KeyboardInterrupt:
        print("\n   Monitoring stopped.")

    print("\nDone.")


if __name__ == "__main__":
    main()
```

Key design decisions:
- Standalone script (not pytest) following existing human-tests pattern
- Connects to real JMAP session to verify eventSourceUrl availability
- Checks health endpoint for SSE status
- Provides clear manual test instructions (user applies label, watches logs)
- Optional automated monitoring loop that watches health endpoint for poll activity
- Reports trigger source (push vs fallback) from service logs

This test validates PUSH-06 (triage latency < 10 seconds) which can only be verified against the real Fastmail service.
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && python -c "import ast; ast.parse(open('human-tests/test_16_eventsource_push.py').read()); print('Syntax OK')"</automated>
  </verify>
  <done>
    - human-tests/test_16_eventsource_push.py exists and has valid Python syntax
    - Script connects to JMAP session and verifies eventSourceUrl availability
    - Script checks health endpoint for SSE status
    - Script provides manual latency test instructions
    - Script includes automated health monitoring loop
    - Script follows existing human-tests patterns (standalone, MAILROOM_ env vars)
  </done>
</task>

</tasks>

<verification>
```bash
# All unit tests pass (existing + new)
cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run pytest tests/ -x -v

# Health endpoint includes eventsource field (verify module compiles)
uv run python -c "
from mailroom.__main__ import HealthHandler
assert hasattr(HealthHandler, 'sse_status'), 'missing sse_status'
assert hasattr(HealthHandler, 'sse_connected_since'), 'missing sse_connected_since'
assert hasattr(HealthHandler, 'sse_last_event_at'), 'missing sse_last_event_at'
assert hasattr(HealthHandler, 'sse_reconnect_count'), 'missing sse_reconnect_count'
assert hasattr(HealthHandler, 'sse_last_error'), 'missing sse_last_error'
print('Health SSE attributes OK')
"

# Main module imports eventsource cleanly
uv run python -c "
import ast
tree = ast.parse(open('src/mailroom/__main__.py').read())
imports = [n for n in ast.walk(tree) if isinstance(n, (ast.Import, ast.ImportFrom))]
eventsource_import = any(
    getattr(n, 'module', '') == 'mailroom.eventsource'
    for n in imports
    if isinstance(n, ast.ImportFrom)
)
assert eventsource_import, '__main__.py must import from mailroom.eventsource'
print('Import check OK')
"

# Human test syntax valid
python -c "import ast; ast.parse(open('human-tests/test_16_eventsource_push.py').read()); print('Human test syntax OK')"
```
</verification>

<success_criteria>
- Main loop uses queue.get(timeout=poll_interval) for combined event-driven + fallback polling
- SSE listener thread starts on service boot when eventSourceUrl is available
- Poll log entries include trigger="push" (SSE-triggered) or trigger="fallback" (timeout)
- Debounce collapse stats logged at DEBUG level
- Health endpoint /healthz includes eventsource status object with all 5 fields
- Graceful shutdown cleanly stops SSE thread via shutdown_event
- Human integration test validates push-triggered triage latency
- Full test suite passes
</success_criteria>

<output>
After completion, create `.planning/phases/08-eventsource-push/08-02-SUMMARY.md`
</output>

---
phase: 07-setup-script
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/mailroom/cli.py
  - src/mailroom/__main__.py
  - src/mailroom/clients/jmap.py
  - src/mailroom/clients/carddav.py
  - tests/test_jmap_client.py
  - tests/test_carddav_client.py
autonomous: true
requirements: [SETUP-01, SETUP-02, SETUP-06]

must_haves:
  truths:
    - "JMAPClient can create a mailbox with name and optional parentId"
    - "JMAPClient exposes session capabilities for downstream sieve checking"
    - "CardDAVClient can create an Apple-style contact group vCard"
    - "CLI framework dispatches 'setup' and 'run' subcommands"
    - "python -m mailroom (no subcommand) still runs the service"
  artifacts:
    - path: "src/mailroom/cli.py"
      provides: "Click CLI group with setup and run subcommands"
      exports: ["cli"]
    - path: "src/mailroom/clients/jmap.py"
      provides: "create_mailbox method and session property"
      exports: ["JMAPClient"]
    - path: "src/mailroom/clients/carddav.py"
      provides: "create_group method for Apple-style contact groups"
      exports: ["CardDAVClient"]
  key_links:
    - from: "src/mailroom/__main__.py"
      to: "src/mailroom/cli.py"
      via: "cli() invocation"
      pattern: "from mailroom\\.cli import cli"
    - from: "src/mailroom/cli.py"
      to: "src/mailroom/__main__.py"
      via: "run subcommand calls main()"
      pattern: "from mailroom\\.__main__ import main"
---

<objective>
Add Click CLI framework with `setup` and `run` subcommands, and extend JMAPClient with `create_mailbox()` and CardDAVClient with `create_group()` for resource provisioning.

Purpose: The setup command needs to create mailboxes and contact groups on Fastmail. This plan adds the CLI entry point and the client-level create operations that the provisioner (Plan 02) will orchestrate.

Output: `cli.py` with Click group, extended JMAP/CardDAV clients with create methods, updated `__main__.py` to dispatch through CLI, all with unit tests.
</objective>

<execution_context>
@/Users/flo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/flo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-setup-script/07-CONTEXT.md
@.planning/phases/07-setup-script/07-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. -->

From src/mailroom/core/config.py:
```python
class MailroomSettings(BaseSettings):
    jmap_token: str
    carddav_username: str = ""
    carddav_password: str = ""
    triage_categories: list[TriageCategory] = Field(default_factory=_default_categories)

    @property
    def required_mailboxes(self) -> list[str]: ...
    @property
    def contact_groups(self) -> list[str]: ...
    @property
    def triage_labels(self) -> list[str]: ...
```

From src/mailroom/clients/jmap.py:
```python
class JMAPClient:
    def __init__(self, token: str, hostname: str = "api.fastmail.com") -> None: ...
    def connect(self) -> None: ...  # discovers session (account_id, api_url)
    def call(self, method_calls: list) -> list: ...
    def resolve_mailboxes(self, required_names: list[str]) -> dict[str, str]: ...
    # NOTE: connect() currently fetches session but does NOT store capabilities or downloadUrl
```

From src/mailroom/clients/carddav.py:
```python
class CardDAVClient:
    def __init__(self, username: str, password: str, hostname: str = "carddav.fastmail.com") -> None: ...
    def connect(self) -> None: ...  # discovers addressbook via PROPFIND chain
    def validate_groups(self, required_groups: list[str]) -> dict[str, dict]: ...
    # NOTE: create_contact() exists and follows the PUT + If-None-Match pattern
```

From src/mailroom/__main__.py:
```python
def main() -> None:
    """Run the Mailroom polling service."""
    # Contains full startup sequence: config, clients, resolve, workflow, health, polling loop
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Click CLI framework and wire __main__.py</name>
  <files>pyproject.toml, src/mailroom/cli.py, src/mailroom/__main__.py</files>
  <action>
1. Add `click` to dependencies in pyproject.toml and run `uv sync`.

2. Create `src/mailroom/cli.py` with a Click group:
   ```python
   import click
   import sys

   @click.group(invoke_without_command=True)
   @click.pass_context
   def cli(ctx):
       """Mailroom: Email triage automation for Fastmail."""
       if ctx.invoked_subcommand is None:
           ctx.invoke(run)

   @cli.command()
   def run():
       """Run the Mailroom polling service."""
       from mailroom.__main__ import main
       main()

   @cli.command()
   @click.option("--apply", is_flag=True, default=False, help="Apply changes (default is dry-run)")
   @click.option("--ui-guide", is_flag=True, default=False, help="Show Fastmail UI instructions instead of sieve snippets")
   def setup(apply, ui_guide):
       """Provision Fastmail resources for configured triage categories."""
       # Stub: Plan 02 will implement run_setup
       click.echo("Setup command not yet implemented.")
       sys.exit(0)
   ```

3. Update `src/mailroom/__main__.py`:
   - Keep the existing `main()` function EXACTLY as-is (it is the polling service)
   - Change the `if __name__ == "__main__":` block to import and call `cli()` instead of `main()` directly:
     ```python
     if __name__ == "__main__":
         from mailroom.cli import cli
         cli()
     ```

4. Add console script entry point in pyproject.toml:
   ```toml
   [project.scripts]
   mailroom = "mailroom.cli:cli"
   ```
   Then run `uv sync` again to install the entry point.

Backward compatibility: `python -m mailroom` with no args invokes `run` via `invoke_without_command=True`, which calls `main()`. The existing Dockerfile CMD is preserved.
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run python -m mailroom --help && uv run python -m mailroom setup --help</automated>
  </verify>
  <done>
    - `python -m mailroom --help` shows group with `run` and `setup` subcommands
    - `python -m mailroom setup --help` shows `--apply` and `--ui-guide` flags
    - `python -m mailroom setup` prints stub message and exits 0
    - `click` is in pyproject.toml dependencies
    - Existing `main()` function is unchanged
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend JMAPClient with create_mailbox and session capabilities</name>
  <files>src/mailroom/clients/jmap.py, tests/test_jmap_client.py</files>
  <action>
1. In `JMAPClient.__init__`, add `self._session_capabilities: dict = {}` and `self._download_url: str | None = None`.

2. In `JMAPClient.connect()`, after parsing the session response, store:
   - `self._session_capabilities = data.get("capabilities", {})`
   - `self._download_url = data.get("downloadUrl")`

3. Add a property to expose capabilities:
   ```python
   @property
   def session_capabilities(self) -> dict:
       """Return session capabilities dict. Empty if not connected."""
       return self._session_capabilities
   ```

4. Add `create_mailbox()` method:
   ```python
   def create_mailbox(self, name: str, parent_id: str | None = None) -> str:
       """Create a mailbox and return its server-assigned ID.

       Args:
           name: Mailbox display name (e.g., "Feed", not "Triage/Feed").
           parent_id: Parent mailbox ID for nested mailboxes, or None for top-level.

       Returns:
           Server-assigned mailbox ID string.

       Raises:
           RuntimeError: If Mailbox/set reports creation failed, with error type and description.
       """
       create_args: dict = {
           "name": name,
           "isSubscribed": True,
       }
       if parent_id is not None:
           create_args["parentId"] = parent_id

       responses = self.call(
           [["Mailbox/set", {
               "accountId": self.account_id,
               "create": {"mb0": create_args},
           }, "c0"]]
       )
       data = responses[0][1]
       created = data.get("created", {})
       if "mb0" in created:
           return created["mb0"]["id"]
       not_created = data.get("notCreated", {})
       error = not_created.get("mb0", {})
       raise RuntimeError(
           f"Failed to create mailbox '{name}': "
           f"{error.get('type', 'unknown')} - {error.get('description', '')}"
       )
   ```

5. Add tests in `tests/test_jmap_client.py`:

   a. **test_create_mailbox_success**: Mock Mailbox/set returning `{"created": {"mb0": {"id": "Ma999"}}}`. Assert returns "Ma999". Verify request payload has name, isSubscribed=True, parentId not present.

   b. **test_create_mailbox_with_parent**: Same but pass parent_id="MaParent". Verify parentId in payload.

   c. **test_create_mailbox_failure**: Mock Mailbox/set returning `{"notCreated": {"mb0": {"type": "invalidProperties", "description": "Name exists"}}}`. Assert raises RuntimeError with "Failed to create mailbox" message containing error type.

   d. **test_connect_stores_capabilities**: Mock session endpoint to return `{"capabilities": {"urn:ietf:params:jmap:core": {}, "urn:ietf:params:jmap:mail": {}}, ...}`. After connect(), assert `client.session_capabilities` contains the expected keys.

   Follow existing test patterns in the file: use `httpx_mock.add_response()` for mocking, create JMAPClient with token, call connect() with mocked session response before testing methods.
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run pytest tests/test_jmap_client.py -x -v -k "create_mailbox or connect_stores"</automated>
  </verify>
  <done>
    - JMAPClient.create_mailbox() creates a mailbox via Mailbox/set and returns the ID
    - JMAPClient.create_mailbox() with parent_id includes parentId in the JMAP call
    - JMAPClient.create_mailbox() raises RuntimeError on notCreated with error details
    - JMAPClient.session_capabilities exposes the session capabilities dict
    - All new and existing tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend CardDAVClient with create_group</name>
  <files>src/mailroom/clients/carddav.py, tests/test_carddav_client.py</files>
  <action>
1. Add `create_group()` method to `CardDAVClient`, following the exact pattern of the existing `create_contact()` method:

   ```python
   def create_group(self, name: str) -> dict:
       """Create an Apple-style contact group vCard in the addressbook.

       Builds a vCard with X-ADDRESSBOOKSERVER-KIND:group marker so that
       validate_groups() can discover it. Uses If-None-Match: * to prevent
       overwriting an existing resource.

       Args:
           name: Group display name (e.g., "Feed", "Paper Trail").

       Returns:
           Dict with 'href', 'etag', and 'uid' keys.

       Raises:
           RuntimeError: If connect() has not been called.
           httpx.HTTPStatusError: On HTTP errors from the PUT.
       """
       addressbook_url = self._require_connection()
       group_uid = str(uuid.uuid4())

       card = vobject.vCard()
       card.add("uid").value = group_uid
       card.add("fn").value = name
       card.add("n").value = vobject.vcard.Name()
       card.add("x-addressbookserver-kind").value = "group"

       href_path = f"{group_uid}.vcf"
       put_url = f"{addressbook_url}{href_path}"

       resp = self._http.put(
           put_url,
           content=card.serialize().encode("utf-8"),
           headers={
               "Content-Type": "text/vcard; charset=utf-8",
               "If-None-Match": "*",
           },
       )
       resp.raise_for_status()

       return {
           "href": f"/{group_uid}.vcf",
           "etag": resp.headers.get("etag", ""),
           "uid": group_uid,
       }
   ```

2. Add tests in `tests/test_carddav_client.py`:

   a. **test_create_group_success**: Mock PUT response with 201 + etag header. Call create_group("Feed"). Assert return dict has href (ending in .vcf), etag, uid. Verify the PUT request body contains `X-ADDRESSBOOKSERVER-KIND:group`, `FN:Feed`, a UID, and `If-None-Match: *` header.

   b. **test_create_group_not_connected**: Call create_group("Feed") without connect(). Assert raises RuntimeError with "not connected" message.

   c. **test_create_group_http_error**: Mock PUT response with 403. Assert raises httpx.HTTPStatusError.

   Follow existing test patterns: use `httpx_mock.add_response()`, set up the client with a mocked connect (mock the PROPFIND chain as done in existing tests).
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run pytest tests/test_carddav_client.py -x -v -k "create_group"</automated>
  </verify>
  <done>
    - CardDAVClient.create_group() creates a group vCard with X-ADDRESSBOOKSERVER-KIND:group
    - CardDAVClient.create_group() uses If-None-Match: * for safety
    - CardDAVClient.create_group() returns href, etag, uid dict
    - CardDAVClient.create_group() raises RuntimeError if not connected
    - All new and existing tests pass
  </done>
</task>

</tasks>

<verification>
```bash
# All unit tests pass
cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run pytest tests/ -x -v

# CLI help works
uv run python -m mailroom --help
uv run python -m mailroom setup --help

# Backward compat: no-subcommand shows run help (will fail without credentials, but should not crash on CLI parsing)
uv run python -m mailroom run --help
```
</verification>

<success_criteria>
- Click CLI with `setup` and `run` subcommands, backward-compatible `python -m mailroom`
- JMAPClient.create_mailbox(name, parent_id) creates mailboxes via Mailbox/set
- JMAPClient.session_capabilities exposes JMAP session capabilities
- CardDAVClient.create_group(name) creates Apple-style contact group vCards
- All existing tests continue to pass (211+)
- New tests cover success, error, and edge cases for create methods
</success_criteria>

<output>
After completion, create `.planning/phases/07-setup-script/07-01-SUMMARY.md`
</output>

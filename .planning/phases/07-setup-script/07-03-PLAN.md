---
phase: 07-setup-script
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - src/mailroom/setup/sieve_checker.py
  - src/mailroom/setup/provisioner.py
  - tests/test_sieve_checker.py
  - human-tests/test_14_setup_dry_run.py
  - human-tests/test_15_setup_apply.py
autonomous: true
requirements: [SETUP-03, SETUP-04, SETUP-05]

must_haves:
  truths:
    - "Setup output includes sieve rule guidance for each category"
    - "Missing sieve rules show copy-paste snippets by default"
    - "--ui-guide flag shows Fastmail UI step-by-step instructions instead"
    - "Sieve checker gracefully degrades when JMAP sieve capability unavailable"
    - "Human test verifies dry-run output format against real Fastmail"
    - "Human test verifies apply creates resources and idempotent re-run"
  artifacts:
    - path: "src/mailroom/setup/sieve_checker.py"
      provides: "Sieve script introspection and rule guidance generation"
      exports: ["check_sieve_rules", "generate_sieve_guidance"]
    - path: "human-tests/test_14_setup_dry_run.py"
      provides: "Live Fastmail dry-run verification"
    - path: "human-tests/test_15_setup_apply.py"
      provides: "Live Fastmail apply + idempotency verification"
  key_links:
    - from: "src/mailroom/setup/provisioner.py"
      to: "src/mailroom/setup/sieve_checker.py"
      via: "run_setup calls sieve checking after resource provisioning"
      pattern: "from mailroom\\.setup\\.sieve_checker import"
    - from: "src/mailroom/setup/sieve_checker.py"
      to: "src/mailroom/clients/jmap.py"
      via: "session_capabilities check and SieveScript/get call"
      pattern: "jmap\\.session_capabilities|jmap\\.call.*SieveScript"
---

<objective>
Add sieve rule checking with guidance output (snippets or UI instructions), and create human integration tests for the complete setup flow against real Fastmail.

Purpose: The sieve guidance completes the setup experience -- after provisioning resources, users need to know how to configure email routing rules. Human tests validate the entire flow against the real Fastmail API.

Output: Sieve checker module, updated provisioner output, and two human test scripts.
</objective>

<execution_context>
@/Users/flo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/flo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-setup-script/07-CONTEXT.md
@.planning/phases/07-setup-script/07-RESEARCH.md
@.planning/phases/07-setup-script/07-01-SUMMARY.md
@.planning/phases/07-setup-script/07-02-SUMMARY.md

<interfaces>
<!-- Interfaces from Plan 01 and 02 that this plan depends on -->

From src/mailroom/clients/jmap.py:
```python
class JMAPClient:
    @property
    def session_capabilities(self) -> dict: ...
    @property
    def account_id(self) -> str: ...
    def call(self, method_calls: list) -> list: ...
    def create_mailbox(self, name: str, parent_id: str | None = None) -> str: ...
```

From src/mailroom/setup/provisioner.py (created in Plan 02):
```python
@dataclass
class ResourceAction:
    kind: str           # "mailbox", "label", "contact_group"
    name: str
    status: str         # "exists", "create", "created", "failed", "skipped"
    parent: str | None
    error: str | None

def run_setup(apply: bool, ui_guide: bool) -> int: ...
def plan_resources(settings, jmap, carddav) -> list[ResourceAction]: ...
def apply_resources(plan, jmap, carddav) -> list[ResourceAction]: ...
```

From src/mailroom/setup/reporting.py (created in Plan 02):
```python
def print_plan(actions: list[ResourceAction], apply: bool) -> None: ...
```

From src/mailroom/core/config.py:
```python
class ResolvedCategory:
    name: str
    label: str
    contact_group: str
    destination_mailbox: str

class MailroomSettings:
    @property
    def label_to_category_mapping(self) -> dict[str, ResolvedCategory]: ...
    @property
    def triage_labels(self) -> list[str]: ...
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build sieve checker and integrate into provisioner output</name>
  <files>src/mailroom/setup/sieve_checker.py, src/mailroom/setup/provisioner.py, tests/test_sieve_checker.py</files>
  <action>
1. Create `src/mailroom/setup/sieve_checker.py`:

   **`check_sieve_rules(jmap, settings) -> dict[str, str]`:**
   - Returns dict mapping category name to sieve status: "found", "missing", "? unknown"
   - Check if `"urn:ietf:params:jmap:sieve"` is in `jmap.session_capabilities`
   - If NOT available: return all categories as `"? unknown"` with a note that sieve API is not available
   - If available:
     a. Call `SieveScript/get` with `ids: null` to get all scripts. Note: the `using` list must include `"urn:ietf:params:jmap:sieve"` -- call jmap.call() directly but first need to handle the fact that call() hardcodes `using` to core+mail. Two options: (1) add a `using` parameter to call(), or (2) build and send the request manually. SIMPLEST: have the sieve checker make a raw httpx call through jmap's http client. But that's reaching into internals. BETTER: add an optional `using` parameter to `jmap.call()` that overrides the default list. This is a small, backward-compatible change.
     b. Find the active script (isActive=true)
     c. Download the script blob via the JMAP downloadUrl template. The downloadUrl is in the session data -- currently not stored. Add `self._download_url` storage in JMAPClient.connect() (already done in Plan 01).
     d. Download blob: GET `downloadUrl` with accountId and blobId substituted
     e. Parse the script text for `fileinto` rules matching category destination mailboxes
     f. For each category, check if a rule exists routing to its destination mailbox
   - Also check for the screener catch-all rule
   - On any JMAP error during sieve fetching, gracefully degrade to "? unknown" for all

   IMPORTANT: Since we don't know if Fastmail exposes the sieve capability, implement the capability check first and degrade gracefully. The sieve parsing is best-effort.

   **Sieve script parsing heuristics:**
   - Look for `fileinto "INBOX.{MailboxName}"` or `fileinto "Triage/{Name}"` patterns
   - Look for `jmapquery` blocks that reference contact group filtering
   - Be generous in matching: any `fileinto` targeting the right mailbox counts as "found"
   - If can't determine: return "? unknown"

   **`generate_sieve_guidance(settings, sieve_statuses, ui_guide: bool) -> str`:**
   - If `ui_guide=False` (default): generate sieve-style snippets for MISSING rules only
     - Each snippet shows the Fastmail UI rule equivalent AND a conceptual sieve snippet
     - Explain that Fastmail sieve cannot filter by contact group directly
     - Show the `jmapquery` pattern that Fastmail UI generates internally (note: LOW confidence, mark as reference)
     - For each missing category:
       ```
       Rule for: {category.name}
         Condition: Sender is in contact group "{category.contact_group}"
         Action: Move to folder "{category.destination_mailbox}"

         # Fastmail internal sieve (generated by UI rules):
         # if jmapquery text:
         # {"fromContactGroupId":"<GROUP_ID>"}
         # .
         # { fileinto "INBOX.{destination}"; }
       ```
   - If `ui_guide=True`: generate step-by-step Fastmail UI instructions
     - For each missing category:
       ```
       Rule for: {category.name}
         1. Go to Settings > Filters & Rules
         2. Click "Add Rule"
         3. Set condition: "Sender is in contact group" = "{category.contact_group}"
         4. Set action: "Move to folder" = "{category.destination_mailbox}"
         5. Click "Save"
       ```
   - Also include the screener catch-all rule guidance:
     ```
     Screener catch-all rule:
       Condition: All other incoming mail (no specific sender match)
       Action: Move to folder "Screener"
     ```
   - Return the full guidance string

2. Update `src/mailroom/setup/provisioner.py` `run_setup()`:
   - After resource plan/apply, call `check_sieve_rules(jmap, settings)`
   - Call `generate_sieve_guidance(settings, statuses, ui_guide)` and print it
   - Show sieve section with header:
     ```
     Sieve Rules
       ✓ Feed routing                    found
       ✗ Paper Trail routing              missing
       ? Jail routing                     unknown
     ```
   - Then show guidance text for missing rules

3. Update `jmap.call()` to accept optional `using` parameter:
   ```python
   def call(self, method_calls: list, using: list[str] | None = None) -> list:
       payload = {
           "using": using or [
               "urn:ietf:params:jmap:core",
               "urn:ietf:params:jmap:mail",
           ],
           "methodCalls": method_calls,
       }
   ```
   This is backward-compatible (no existing callers pass `using`).

4. Add `download_blob(blob_id: str) -> bytes` to JMAPClient for sieve script content retrieval:
   ```python
   def download_blob(self, blob_id: str) -> bytes:
       """Download a blob by ID using the session downloadUrl template."""
       if self._download_url is None:
           raise RuntimeError("JMAPClient is not connected. Call connect() first.")
       url = self._download_url.replace("{accountId}", self.account_id).replace("{blobId}", blob_id).replace("{type}", "application/octet-stream").replace("{name}", "blob")
       resp = self._http.get(url)
       resp.raise_for_status()
       return resp.content
   ```

5. Create `tests/test_sieve_checker.py`:

   a. **test_check_sieve_no_capability**: Mock session_capabilities without sieve URI. Assert all categories return "? unknown".

   b. **test_check_sieve_with_rules**: Mock session_capabilities WITH sieve URI. Mock SieveScript/get returning a script with blobId. Mock blob download returning sieve text with `fileinto` rules for some categories. Assert found/missing statuses.

   c. **test_check_sieve_graceful_error**: Mock sieve capability present but SieveScript/get raises error. Assert all return "? unknown".

   d. **test_generate_guidance_sieve_snippets**: Call generate_sieve_guidance with ui_guide=False, verify output contains condition/action pairs and sieve reference code for missing rules only.

   e. **test_generate_guidance_ui_instructions**: Call with ui_guide=True, verify output contains step-by-step Fastmail UI instructions.

   f. **test_generate_guidance_nothing_missing**: All statuses "found". Verify guidance says all rules configured.
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run pytest tests/test_sieve_checker.py -x -v</automated>
  </verify>
  <done>
    - Sieve checker queries JMAP sieve capability and checks for routing rules
    - Graceful degradation to "? unknown" when sieve API unavailable
    - Default output shows sieve-style snippets for missing rules
    - --ui-guide shows Fastmail UI step-by-step instructions
    - Screener catch-all rule checked and guidance shown
    - jmap.call() accepts optional using parameter (backward compatible)
    - All unit tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Create human integration tests for setup dry-run and apply</name>
  <files>human-tests/test_14_setup_dry_run.py, human-tests/test_15_setup_apply.py</files>
  <action>
1. Create `human-tests/test_14_setup_dry_run.py`:
   - Follow existing human test pattern: standalone script, own connections, dotenv, step-level PASS/FAIL
   - Load .env for credentials
   - Steps:
     a. Run `mailroom setup` (dry-run) by importing and calling run_setup(apply=False, ui_guide=False)
     b. Verify output contains the three resource groups (Mailboxes, Action Labels, Contact Groups)
     c. Verify no changes were made to Fastmail (run resolve_mailboxes / validate_groups before and after, compare)
     d. Verify exit code 0
     e. Print captured output for human review
   - Report PASS/FAIL per step

2. Create `human-tests/test_15_setup_apply.py`:
   - Load .env for credentials
   - Steps:
     a. Record existing state (which mailboxes and groups exist)
     b. Run `mailroom setup --apply` by calling run_setup(apply=True, ui_guide=False)
     c. Verify resources were created (re-check with resolve_mailboxes / validate_groups)
     d. Verify output shows "created" statuses for new items
     e. **Idempotency test**: Run `mailroom setup --apply` a SECOND time
     f. Verify second run shows all "exists" with no new creations
     g. Verify exit code 0 on both runs
     h. Print summary for human review
     i. NOTE: this test creates REAL resources on Fastmail. Include a header warning. Resources created are the standard triage infrastructure that the user wants anyway.
   - Report PASS/FAIL per step

   Follow existing human test conventions:
   - `import sys, os; sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))`
   - `from dotenv import load_dotenv; load_dotenv()`
   - Step numbering with PASS/FAIL emoji
   - Standalone: `python human-tests/test_14_setup_dry_run.py`
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run python -c "import ast; ast.parse(open('human-tests/test_14_setup_dry_run.py').read()); ast.parse(open('human-tests/test_15_setup_apply.py').read()); print('syntax ok')"</automated>
  </verify>
  <done>
    - test_14_setup_dry_run.py verifies dry-run output format and no-change guarantee
    - test_15_setup_apply.py verifies resource creation and idempotent re-run
    - Both follow existing human test patterns (standalone, dotenv, PASS/FAIL steps)
    - Syntax valid (verified by ast.parse)
    - Scripts are runnable with `python human-tests/test_14_setup_dry_run.py`
  </done>
</task>

</tasks>

<verification>
```bash
# All unit tests pass
cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run pytest tests/ -x -v

# Full CLI check
uv run python -m mailroom setup --help

# Human test syntax check
uv run python -c "import ast; ast.parse(open('human-tests/test_14_setup_dry_run.py').read()); ast.parse(open('human-tests/test_15_setup_apply.py').read()); print('ok')"
```
</verification>

<success_criteria>
- Sieve rules section appears in setup output with found/missing/unknown statuses
- Missing rules show sieve snippets by default, UI instructions with --ui-guide
- Sieve checker gracefully handles missing JMAP sieve capability
- Human test test_14 validates dry-run against real Fastmail
- Human test test_15 validates apply + idempotency against real Fastmail
- All unit tests pass (existing + new)
</success_criteria>

<output>
After completion, create `.planning/phases/07-setup-script/07-03-SUMMARY.md`
</output>

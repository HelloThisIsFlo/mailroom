---
phase: 07-setup-script
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - src/mailroom/setup/sieve_guidance.py
  - src/mailroom/setup/provisioner.py
  - tests/test_sieve_guidance.py
  - human-tests/test_14_setup_dry_run.py
  - human-tests/test_15_setup_apply.py
autonomous: true
requirements: [SETUP-03, SETUP-04, SETUP-05]

must_haves:
  truths:
    - "Setup output includes sieve rule guidance for ALL configured categories"
    - "Default output shows copy-paste sieve-style snippets for every category"
    - "--ui-guide flag shows Fastmail Settings UI step-by-step instructions instead"
    - "Screener catch-all rule guidance is always included"
    - "Human test verifies dry-run output format against real Fastmail"
    - "Human test verifies apply creates resources and idempotent re-run"
  artifacts:
    - path: "src/mailroom/setup/sieve_guidance.py"
      provides: "Sieve rule guidance generation for all categories"
      exports: ["generate_sieve_guidance"]
    - path: "human-tests/test_14_setup_dry_run.py"
      provides: "Live Fastmail dry-run verification"
    - path: "human-tests/test_15_setup_apply.py"
      provides: "Live Fastmail apply + idempotency verification"
  key_links:
    - from: "src/mailroom/setup/provisioner.py"
      to: "src/mailroom/setup/sieve_guidance.py"
      via: "run_setup calls generate_sieve_guidance after resource provisioning"
      pattern: "from mailroom\\.setup\\.sieve_guidance import"
    - from: "src/mailroom/setup/sieve_guidance.py"
      to: "src/mailroom/core/config.py"
      via: "reads resolved categories and screener_mailbox from settings"
      pattern: "settings\\._resolved_categories|settings\\.screener_mailbox"
---

<objective>
Add sieve rule guidance output (snippets or Fastmail UI instructions) for all configured categories, and create human integration tests for the complete setup flow against real Fastmail.

Purpose: After provisioning mailboxes and contact groups, users need clear instructions for the one manual step: creating email routing rules. This plan generates guidance for ALL categories unconditionally (no sieve introspection -- that is deferred to a future milestone). Human tests validate the entire setup flow against real Fastmail.

Output: `sieve_guidance.py` module, updated provisioner output with guidance section, unit tests, and two human test scripts.
</objective>

<execution_context>
@/Users/flo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/flo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-setup-script/07-CONTEXT.md
@.planning/phases/07-setup-script/07-RESEARCH.md
@.planning/phases/07-setup-script/07-01-SUMMARY.md
@.planning/phases/07-setup-script/07-02-SUMMARY.md

<interfaces>
<!-- Interfaces from Plan 01 and 02 that this plan depends on -->

From src/mailroom/setup/provisioner.py (created in Plan 02):
```python
@dataclass
class ResourceAction:
    kind: str           # "mailbox", "label", "contact_group"
    name: str
    status: str         # "exists", "create", "created", "failed", "skipped"
    parent: str | None
    error: str | None

def run_setup(apply: bool, ui_guide: bool) -> int: ...
def plan_resources(settings, jmap, carddav) -> list[ResourceAction]: ...
def apply_resources(plan, jmap, carddav) -> list[ResourceAction]: ...
```

From src/mailroom/setup/reporting.py (created in Plan 02):
```python
def print_plan(actions: list[ResourceAction], apply: bool) -> None: ...
```

From src/mailroom/core/config.py:
```python
@dataclass(frozen=True)
class ResolvedCategory:
    name: str
    label: str
    contact_group: str
    destination_mailbox: str
    contact_type: str
    parent: str | None

class MailroomSettings(BaseSettings):
    screener_mailbox: str = "Screener"
    triage_categories: list[TriageCategory] = Field(default_factory=_default_categories)
    _resolved_categories: list[ResolvedCategory]  # set by model_validator

    @property
    def required_mailboxes(self) -> list[str]: ...
    @property
    def contact_groups(self) -> list[str]: ...
    @property
    def triage_labels(self) -> list[str]: ...
    @property
    def label_to_category_mapping(self) -> dict[str, ResolvedCategory]: ...
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build sieve guidance module and integrate into provisioner</name>
  <files>src/mailroom/setup/sieve_guidance.py, src/mailroom/setup/provisioner.py, tests/test_sieve_guidance.py</files>
  <action>
1. Create `src/mailroom/setup/sieve_guidance.py` with a single public function:

   ```python
   """Sieve rule guidance for Mailroom setup.

   Generates human-readable instructions for creating email routing rules.
   No sieve introspection -- just prints what rules are needed for all
   configured categories. A future milestone will add JMAP Contacts
   migration and programmatic sieve rule creation.
   """

   from __future__ import annotations
   from typing import TYPE_CHECKING

   if TYPE_CHECKING:
       from mailroom.core.config import MailroomSettings


   def generate_sieve_guidance(settings: MailroomSettings, *, ui_guide: bool = False) -> str:
       ...
   ```

   The function reads `settings._resolved_categories` to iterate over all categories. It also reads `settings.screener_mailbox` for the catch-all rule.

   **Default mode (`ui_guide=False`):** Generate copy-paste sieve-style snippets for every category. The output should look like:

   ```
   Sieve Rules

     Routing rules route incoming mail from categorized contacts to the
     correct mailbox. Create these rules in Fastmail:
       Settings > Filters & Rules > Add Rule

     Note: Fastmail sieve cannot filter by contact group directly.
     These rules must be created through the Fastmail UI, which uses
     the jmapquery extension internally.

     Per-category rules:

       Feed
         Condition: Sender is in contact group "Feed"
         Action: Move to folder "Feed"

         # Fastmail sieve equivalent (generated by the UI):
         # require ["vnd.cyrus.jmapquery", "fileinto"];
         # if jmapquery text:
         # {"fromContactGroupId":"<Feed_GROUP_ID>"}
         # .
         # { fileinto "INBOX.Feed"; }

       Paper Trail
         Condition: Sender is in contact group "Paper Trail"
         Action: Move to folder "Paper Trail"

         # Fastmail sieve equivalent (generated by the UI):
         # require ["vnd.cyrus.jmapquery", "fileinto"];
         # if jmapquery text:
         # {"fromContactGroupId":"<Paper Trail_GROUP_ID>"}
         # .
         # { fileinto "INBOX.Paper Trail"; }

       ... (one block per category)

     Screener catch-all rule:

       Screener
         Condition: All other incoming mail (no specific sender match)
         Action: Move to folder "Screener"

         # This rule should be ordered LAST, after all category rules.
         # It catches any mail not matched by the per-category rules above.
   ```

   **Important details for default mode:**
   - Skip categories whose `parent` is not None (child categories like "Person" inherit routing from their parent "Imbox" -- they don't need separate rules)
   - For each root category, show the contact_group as the condition and destination_mailbox as the action
   - The sieve reference snippet is informational only (note LOW confidence on exact jmapquery JSON format)
   - Include a header explaining the rules must be created via Fastmail UI
   - Include the screener catch-all at the end

   **`--ui-guide` mode (`ui_guide=True`):** Generate step-by-step Fastmail Settings UI instructions:

   ```
   Sieve Rules

     Step-by-step instructions for creating routing rules in Fastmail.

     For each rule below:
       1. Go to Fastmail Settings > Filters & Rules
       2. Click "Add Rule"
       3. Set the condition and action as described
       4. Click "Save"
       5. Ensure rules are ordered: category rules first, screener catch-all last

     Per-category rules:

       Feed
         Step 3a: Set condition to "Sender is in contact group" = "Feed"
         Step 3b: Set action to "Move to folder" = "Feed"

       Paper Trail
         Step 3a: Set condition to "Sender is in contact group" = "Paper Trail"
         Step 3b: Set action to "Move to folder" = "Paper Trail"

       ... (one block per category)

     Screener catch-all rule:

       Screener
         Step 3a: Set condition to "All messages" (or leave blank for catch-all)
         Step 3b: Set action to "Move to folder" = "Screener"

         Important: This rule must be LAST in the rule list.
   ```

   - Same logic: skip child categories, include screener catch-all
   - More concise, focused on UI steps rather than sieve syntax

   Return the full multiline guidance string (no printing -- the caller prints it).

2. Update `src/mailroom/setup/provisioner.py` `run_setup()`:
   - After the resource plan/apply output and BEFORE returning the exit code, call `generate_sieve_guidance(settings, ui_guide=ui_guide)`
   - Print the returned guidance string with `click.echo()` (or plain `print()`)
   - This should happen in BOTH dry-run and apply modes (the user always needs to see what rules to create)
   - Add the import: `from mailroom.setup.sieve_guidance import generate_sieve_guidance`

3. Create `tests/test_sieve_guidance.py` with unit tests:

   a. **test_generate_guidance_default_mode**: Create a MailroomSettings with default categories (set MAILROOM_JMAP_TOKEN env var in fixture). Call `generate_sieve_guidance(settings, ui_guide=False)`. Assert output contains:
      - "Sieve Rules" header
      - Section for "Feed" with condition mentioning contact group "Feed" and action mentioning folder "Feed"
      - Section for "Imbox" with action mentioning folder "Inbox" (destination_mailbox for Imbox is "Inbox")
      - Section for "Paper Trail"
      - Section for "Jail"
      - NO section for "Person" (child of Imbox, should be skipped)
      - Screener catch-all section mentioning "Screener"
      - sieve reference snippet containing "fileinto" and "jmapquery"

   b. **test_generate_guidance_ui_guide_mode**: Same settings. Call with `ui_guide=True`. Assert output contains:
      - "Sieve Rules" header
      - "Filters & Rules" (UI navigation reference)
      - Per-category steps mentioning "contact group" condition and "Move to folder" action
      - Screener catch-all with "LAST" ordering note
      - Does NOT contain sieve code (no "fileinto", no "jmapquery")

   c. **test_generate_guidance_custom_categories**: Create settings with custom categories (e.g., add a "Receipts" category). Assert output includes guidance for "Receipts" alongside defaults.

   d. **test_generate_guidance_skips_child_categories**: Create settings with default categories. Assert "Person" does NOT appear as a separate rule section in the output (it inherits routing from its parent "Imbox").

   e. **test_generate_guidance_screener_catch_all**: Verify the screener section uses settings.screener_mailbox value. Create settings with a custom screener_mailbox="MyScreener". Assert output mentions "MyScreener".

   Use monkeypatch or environment variable fixtures to construct MailroomSettings:
   ```python
   @pytest.fixture
   def settings(monkeypatch):
       monkeypatch.setenv("MAILROOM_JMAP_TOKEN", "test-token")
       monkeypatch.setenv("MAILROOM_CARDDAV_USERNAME", "test")
       monkeypatch.setenv("MAILROOM_CARDDAV_PASSWORD", "test")
       return MailroomSettings()
   ```
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run pytest tests/test_sieve_guidance.py -x -v</automated>
  </verify>
  <done>
    - sieve_guidance.py generates guidance for ALL root categories (skips children)
    - Default mode shows sieve-style snippets with contact group conditions and destination mailbox actions
    - --ui-guide mode shows Fastmail Settings UI step-by-step instructions
    - Screener catch-all rule guidance included in both modes
    - Provisioner prints guidance after resource plan/apply output
    - All unit tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Create human integration tests for setup dry-run and apply</name>
  <files>human-tests/test_14_setup_dry_run.py, human-tests/test_15_setup_apply.py</files>
  <action>
1. Create `human-tests/test_14_setup_dry_run.py`:

   Follow the existing human test pattern from test_13 and earlier tests:
   - Standalone script, own connections, dotenv, step-level PASS/FAIL
   - Path setup: `sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))`
   - Load .env: `from dotenv import load_dotenv; load_dotenv(Path(__file__).resolve().parent.parent / ".env")`

   ```
   """Human test 14: Setup Dry Run (reads real Fastmail, makes NO changes).

   Validates the setup command in dry-run mode:
     - Connects to JMAP and CardDAV (pre-flight check)
     - Shows resource plan with Mailboxes, Action Labels, Contact Groups
     - Shows sieve rule guidance for all categories
     - Makes NO changes to Fastmail (verify state unchanged)
     - Exit code 0

   Prerequisites:
     - Tests 1-12 pass
     - .env file with Fastmail credentials
   """
   ```

   Steps:
   a. **Step 1: Pre-flight connectivity** -- Import MailroomSettings, JMAPClient, CardDAVClient. Connect both. If either fails, FAIL with clear message.

   b. **Step 2: Record initial state** -- Call `jmap.resolve_mailboxes(settings.required_mailboxes)` (catch ValueError for missing ones, that's OK) and `carddav.list_groups()` (or `validate_groups` with try/except). Record the sets of existing mailbox names and group names.

   c. **Step 3: Run dry-run** -- Import `run_setup` from `mailroom.setup.provisioner`. Capture stdout using `io.StringIO` and `contextlib.redirect_stdout`. Call `run_setup(apply=False, ui_guide=False)`. Capture the exit code.

   d. **Step 4: Verify output format** -- Check captured output contains:
      - "Mailboxes" section header
      - "Action Labels" section header
      - "Contact Groups" section header
      - "Sieve Rules" section
      - At least one status indicator (exists or create)

   e. **Step 5: Verify no changes** -- Re-check mailboxes and groups. Assert the sets are identical to Step 2 (no new resources created).

   f. **Step 6: Verify exit code** -- Assert exit code is 0.

   Print captured output for human review. Report PASS/FAIL per step.

2. Create `human-tests/test_15_setup_apply.py`:

   ```
   """Human test 15: Setup Apply + Idempotency (CREATES resources on real Fastmail).

   Validates the setup command in apply mode:
     - Creates missing mailboxes and contact groups on Fastmail
     - Reports created/existing statuses
     - Shows sieve rule guidance
     - Idempotent: second run shows all "exists"
     - Exit code 0 on both runs

   Prerequisites:
     - Test 14 passes (dry-run works)
     - .env file with Fastmail credentials

   WARNING: This test creates REAL resources on your Fastmail account.
   The resources created are the standard triage infrastructure (mailboxes
   and contact groups) that Mailroom needs to operate. They are safe to
   keep -- you will want them for normal Mailroom usage.
   """
   ```

   Steps:
   a. **Step 1: First apply run** -- Call `run_setup(apply=True, ui_guide=False)`. Capture stdout. Record exit code.

   b. **Step 2: Verify resources created** -- Connect fresh clients. Use `jmap.resolve_mailboxes(settings.required_mailboxes)` -- should succeed without ValueError (all mailboxes exist). Use `carddav.validate_groups(settings.contact_groups)` -- should succeed. Print what was found.

   c. **Step 3: Verify first run output** -- Check captured output contains at least one "created" or "exists" status. Check sieve guidance section is present.

   d. **Step 4: Idempotency test** -- Call `run_setup(apply=True, ui_guide=False)` a SECOND time. Capture stdout.

   e. **Step 5: Verify second run all exists** -- Check captured output from second run. Verify it does NOT contain "create" actions (only "exists"). Summary line should show "0 created" or all existing.

   f. **Step 6: Verify exit codes** -- Both runs should return exit code 0.

   Print captured output for human review. Report PASS/FAIL per step.

   NOTE: run_setup calls sys.exit() -- to capture the exit code without exiting the test script, wrap the call: catch SystemExit and extract the code. Example:
   ```python
   try:
       run_setup(apply=True, ui_guide=False)
       exit_code = 0
   except SystemExit as e:
       exit_code = e.code
   ```
   Actually, re-check Plan 02: run_setup returns an int exit code, and the CLI calls sys.exit(). So calling run_setup directly from the test script should just return the int. No SystemExit to catch.
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run python -c "import ast; ast.parse(open('human-tests/test_14_setup_dry_run.py').read()); ast.parse(open('human-tests/test_15_setup_apply.py').read()); print('syntax ok')"</automated>
  </verify>
  <done>
    - test_14_setup_dry_run.py verifies dry-run output format, sieve guidance, and no-change guarantee
    - test_15_setup_apply.py verifies resource creation, sieve guidance, and idempotent re-run
    - Both follow existing human test patterns (standalone, dotenv, step-level PASS/FAIL)
    - Syntax valid (verified by ast.parse)
    - Scripts are runnable with `python human-tests/test_14_setup_dry_run.py`
  </done>
</task>

</tasks>

<verification>
```bash
# All unit tests pass (existing + new sieve guidance tests)
cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run pytest tests/ -x -v

# Full CLI check -- setup shows sieve guidance in help
uv run python -m mailroom setup --help

# Human test syntax check
uv run python -c "import ast; ast.parse(open('human-tests/test_14_setup_dry_run.py').read()); ast.parse(open('human-tests/test_15_setup_apply.py').read()); print('ok')"
```
</verification>

<success_criteria>
- Sieve guidance section appears in setup output for ALL configured categories
- Default mode shows sieve-style snippets with contact group conditions and folder actions
- --ui-guide mode shows Fastmail Settings UI step-by-step instructions
- Child categories (e.g., Person) are skipped (inherit routing from parent)
- Screener catch-all rule guidance always included
- No sieve introspection -- no SieveScript/get, no capability checking, no download_blob
- Human test test_14 validates dry-run against real Fastmail with no changes
- Human test test_15 validates apply + idempotency against real Fastmail
- All unit tests pass (existing + new)
</success_criteria>

<output>
After completion, create `.planning/phases/07-setup-script/07-03-SUMMARY.md`
</output>

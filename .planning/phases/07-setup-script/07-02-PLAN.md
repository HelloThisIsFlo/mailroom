---
phase: 07-setup-script
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/mailroom/setup/__init__.py
  - src/mailroom/setup/provisioner.py
  - src/mailroom/setup/reporting.py
  - src/mailroom/cli.py
  - tests/test_provisioner.py
autonomous: true
requirements: [SETUP-01, SETUP-02, SETUP-03, SETUP-05, SETUP-06]

must_haves:
  truths:
    - "Dry-run shows what would be created without changing Fastmail"
    - "--apply creates missing mailboxes and contact groups on Fastmail"
    - "Second run of --apply reports all items as 'exists' with no duplicates"
    - "Failed resource creation is reported inline with error reason"
    - "Parent mailbox failure causes child mailboxes to be skipped"
    - "Pre-flight check validates JMAP and CardDAV connectivity before provisioning"
    - "Exit code 0 when all good, 1 when any failure"
  artifacts:
    - path: "src/mailroom/setup/provisioner.py"
      provides: "plan_resources and apply_resources orchestration"
      exports: ["run_setup", "ResourceAction", "plan_resources", "apply_resources"]
    - path: "src/mailroom/setup/reporting.py"
      provides: "Output formatting with terraform-style resource table"
      exports: ["print_plan", "print_result"]
  key_links:
    - from: "src/mailroom/cli.py"
      to: "src/mailroom/setup/provisioner.py"
      via: "setup command calls run_setup()"
      pattern: "from mailroom\\.setup\\.provisioner import run_setup"
    - from: "src/mailroom/setup/provisioner.py"
      to: "src/mailroom/clients/jmap.py"
      via: "create_mailbox calls"
      pattern: "jmap\\.create_mailbox"
    - from: "src/mailroom/setup/provisioner.py"
      to: "src/mailroom/clients/carddav.py"
      via: "create_group calls"
      pattern: "carddav\\.create_group"
    - from: "src/mailroom/setup/provisioner.py"
      to: "src/mailroom/core/config.py"
      via: "reads settings.required_mailboxes and settings.contact_groups"
      pattern: "settings\\.(required_mailboxes|contact_groups|triage_labels)"
---

<objective>
Build the provisioner that orchestrates resource creation with dry-run/apply pattern, and the reporting module that formats terraform-style output with hierarchy, status symbols, and summary line.

Purpose: This is the core of the setup command -- it plans what resources need creating, checks what already exists, creates missing ones on apply, and reports everything in a structured scannable format.

Output: Working `mailroom setup` (dry-run) and `mailroom setup --apply` with full resource provisioning, error handling, and reporting.
</objective>

<execution_context>
@/Users/flo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/flo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-setup-script/07-CONTEXT.md
@.planning/phases/07-setup-script/07-RESEARCH.md
@.planning/phases/07-setup-script/07-01-SUMMARY.md

<interfaces>
<!-- Interfaces from Plan 01 that this plan depends on -->

From src/mailroom/cli.py (created in Plan 01):
```python
@cli.command()
@click.option("--apply", is_flag=True, default=False)
@click.option("--ui-guide", is_flag=True, default=False)
def setup(apply, ui_guide):
    """Provision Fastmail resources for configured triage categories."""
    # Stub -- this plan wires in the real implementation
```

From src/mailroom/clients/jmap.py (extended in Plan 01):
```python
class JMAPClient:
    def create_mailbox(self, name: str, parent_id: str | None = None) -> str: ...
    def resolve_mailboxes(self, required_names: list[str]) -> dict[str, str]: ...
    @property
    def session_capabilities(self) -> dict: ...
    @property
    def account_id(self) -> str: ...
```

From src/mailroom/clients/carddav.py (extended in Plan 01):
```python
class CardDAVClient:
    def create_group(self, name: str) -> dict: ...
    def validate_groups(self, required_groups: list[str]) -> dict[str, dict]: ...
```

From src/mailroom/core/config.py:
```python
class MailroomSettings(BaseSettings):
    jmap_token: str
    carddav_username: str = ""
    carddav_password: str = ""
    screener_mailbox: str = "Screener"
    label_mailroom_error: str = "@MailroomError"
    label_mailroom_warning: str = "@MailroomWarning"
    warnings_enabled: bool = True

    @property
    def required_mailboxes(self) -> list[str]:
        """Returns sorted list including Inbox, screener, error/warning labels, triage labels, and destination mailboxes."""
    @property
    def contact_groups(self) -> list[str]:
        """Returns sorted unique contact group names from resolved categories."""
    @property
    def triage_labels(self) -> list[str]:
        """Returns triage label names (e.g., @ToFeed, @ToImbox)."""
    @property
    def label_to_category_mapping(self) -> dict[str, ResolvedCategory]: ...

class ResolvedCategory:  # frozen dataclass
    name: str
    label: str
    contact_group: str
    destination_mailbox: str
    contact_type: str
    parent: str | None
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build provisioner with plan/apply pattern and reporting</name>
  <files>src/mailroom/setup/__init__.py, src/mailroom/setup/provisioner.py, src/mailroom/setup/reporting.py</files>
  <action>
1. Create `src/mailroom/setup/__init__.py` (empty).

2. Create `src/mailroom/setup/reporting.py` with output formatting:

   Define a `ResourceAction` dataclass:
   ```python
   @dataclass
   class ResourceAction:
       kind: str           # "mailbox", "label", "contact_group"
       name: str           # Display name (e.g., "Feed", "@ToFeed")
       status: str         # "exists", "create", "created", "failed", "skipped"
       parent: str | None  # For mailbox hierarchy display
       error: str | None   # Inline error reason for failures
   ```

   Implement `print_plan(actions: list[ResourceAction], apply: bool) -> None`:
   - Group actions by kind into three sections: **Mailboxes**, **Action Labels**, **Contact Groups**
   - For Mailboxes: show as indented tree. System mailboxes (Inbox, Screener) at top level, then error/warning labels, then destination mailboxes. Triage label mailboxes are "Action Labels" group.
   - Status symbols: `+` for create (dry-run), `✓` for exists/created, `✗` for FAILED, `⊘` for skipped
   - Format:
     ```
     Mailboxes
       ✓ Inbox                          exists
       ✓ Screener                       exists
       + Feed                           create
       + Paper Trail                    create

     Action Labels
       ✓ @ToImbox                       exists
       + @ToFeed                        create
       + @MailroomError                 exists

     Contact Groups
       ✓ Imbox                          exists
       + Feed                           create
     ```
   - For failed items: `✗ Feed                           FAILED: 403 Forbidden`
   - For skipped items: `⊘ Feed                           skipped (parent failed)`
   - Summary line at bottom: `N created · N existing` (apply mode) or `N to create · N existing` (dry-run)
   - Include failure count in summary if any: `N created · N existing · N failed`

3. Create `src/mailroom/setup/provisioner.py` with the orchestration logic:

   **Resource categorization per CONTEXT.md:**
   - "Mailboxes" = destination mailboxes from categories (Feed, Paper Trail, Jail, Inbox) plus system mailboxes (Screener, @MailroomError, @MailroomWarning). These are all from `settings.required_mailboxes` MINUS triage labels.
   - "Action Labels" = triage labels from `settings.triage_labels` (e.g., @ToFeed, @ToImbox, @ToPaperTrail, @ToJail, @ToPerson).
   - "Contact Groups" = `settings.contact_groups` (e.g., Imbox, Feed, Paper Trail, Jail).

   Implement `plan_resources(settings, jmap, carddav) -> list[ResourceAction]`:
   - Fetch existing mailboxes via `jmap.resolve_mailboxes()` -- but catch ValueError for missing ones (that's the point: we're finding what's missing)
   - Actually: do a Mailbox/get to get ALL mailboxes, then compare. Use `jmap.call()` directly to get all mailbox names, like resolve_mailboxes does internally. Build a set of existing mailbox names.
   - Fetch existing groups via a modified approach: call `carddav.validate_groups()` but catch the ValueError; or better, add a helper that fetches all group names without requiring them to exist. The simplest approach: try validate_groups with each group individually, or fetch all vCards once and check names. Use the same REPORT approach as validate_groups internally.
   - SIMPLEST APPROACH: For mailboxes, call `jmap.call([["Mailbox/get", {"accountId": jmap.account_id, "ids": None}, "m0"]])` to get all mailboxes, build name set. For groups, use `carddav.validate_groups([])` -- wait, that won't work with empty list. Instead, add a `list_groups()` method to CardDAVClient... No, keep it simple: do a manual REPORT call through the existing client to fetch all vCards and filter groups, OR just try validate_groups with the full list and catch ValueError to find which are missing.
   - BEST APPROACH for mailboxes: Call `jmap.call()` to Mailbox/get with ids=None, build a dict of name->id (same logic as resolve_mailboxes but without raising on missing). For each resource in required_mailboxes, check if it exists.
   - BEST APPROACH for groups: Fetch all group vCards using the same REPORT pattern as validate_groups but returning ALL found groups, then check which required ones exist. To avoid adding a new public method, use a try/except on validate_groups: try with all required groups, catch ValueError, parse the missing names from the error message. Actually this is fragile. Better: add a `list_groups() -> dict[str, dict]` method that returns all found groups (the first part of validate_groups without the missing check). This is a small, clean addition.
   - NOTE: Actually, add a `list_groups()` to CardDAVClient that does what validate_groups does but returns all found groups without checking for required ones. This is the cleanest approach. Add it in THIS plan since it's a small helper needed for provisioning.

   For each resource, create a ResourceAction with status "exists" or "create".

   Implement `apply_resources(plan, jmap, carddav) -> list[ResourceAction]`:
   - For each action with status "create", attempt to create it
   - Mailboxes: call `jmap.create_mailbox(name, parent_id)`. For the parent_id, look up the name in the existing mailboxes dict. Note: most mailboxes are top-level (parentId=None). The config system uses flat names, not hierarchical paths.
   - Contact groups: call `carddav.create_group(name)`
   - On success: update status to "created"
   - On failure: update status to "failed", store error message
   - Skip resources whose parent failed (status "skipped", error "parent failed")
   - Process in order: mailboxes first (parents before children), then action labels (which are also mailboxes), then contact groups
   - Return updated plan

   Implement `run_setup(apply: bool, ui_guide: bool) -> int`:
   - Load config: `settings = MailroomSettings()`
   - Configure logging: `configure_logging(settings.log_level)`
   - Pre-flight: connect JMAP and CardDAV clients, catch connection errors and report them clearly (exit 1)
   - Plan: call plan_resources()
   - Report: call print_plan() with dry-run output
   - If not apply: exit 0
   - If apply: call apply_resources(), then print_plan() with apply results
   - Return exit code: 0 if no failures, 1 if any failed

   **Pre-flight connectivity check:**
   - Connect JMAPClient -- catches httpx.HTTPStatusError (401 bad token) and httpx.ConnectError (network)
   - Connect CardDAVClient -- same error handling
   - Print clear messages: "JMAP connection failed: {reason}" / "CardDAV connection failed: {reason}"
   - Exit 1 on any pre-flight failure

4. Add `list_groups()` to `CardDAVClient` (small helper). This is the same logic as the first half of `validate_groups()` but returns all found groups as `dict[str, dict]` without requiring specific groups. Place it right before `validate_groups()` in the file.

   ```python
   def list_groups(self) -> dict[str, dict]:
       """Fetch all contact groups from the addressbook.

       Returns:
           Dict mapping group FN to {"href": ..., "etag": ..., "uid": ...}.
       """
       addressbook_url = self._require_connection()
       resp = self._http.request(
           "REPORT", addressbook_url, content=REPORT_ALL_VCARDS,
           headers={"Depth": "1"},
       )
       resp.raise_for_status()
       all_items = self._parse_multistatus(resp.content)
       groups: dict[str, dict] = {}
       for item in all_items:
           vcard_data = item.get("vcard_data", "")
           if not vcard_data:
               continue
           card = vobject.readOne(vcard_data)
           kind_list = card.contents.get("x-addressbookserver-kind", [])
           if not kind_list or kind_list[0].value.lower() != "group":
               continue
           fn = card.fn.value
           groups[fn] = {
               "href": item["href"],
               "etag": item["etag"],
               "uid": card.uid.value,
           }
       return groups
   ```
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run python -c "from mailroom.setup.provisioner import run_setup, ResourceAction, plan_resources; from mailroom.setup.reporting import print_plan; print('imports ok')"</automated>
  </verify>
  <done>
    - provisioner.py has run_setup(), plan_resources(), apply_resources()
    - reporting.py has ResourceAction dataclass and print_plan()
    - Resources categorized into Mailboxes, Action Labels, Contact Groups per CONTEXT.md
    - Status symbols use unicode: +, checkmark, X, circle-slash
    - Summary line shows counts at bottom
    - Pre-flight connectivity check on both JMAP and CardDAV
    - Parent-child dependency: child skipped when parent fails
    - list_groups() added to CardDAVClient
    - All imports work
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire CLI setup command to provisioner and add unit tests</name>
  <files>src/mailroom/cli.py, tests/test_provisioner.py</files>
  <action>
1. Update `src/mailroom/cli.py` setup command to call the real provisioner:
   ```python
   @cli.command()
   @click.option("--apply", is_flag=True, default=False, help="Apply changes (default is dry-run)")
   @click.option("--ui-guide", is_flag=True, default=False, help="Show Fastmail UI instructions instead of sieve snippets")
   def setup(apply, ui_guide):
       """Provision Fastmail resources for configured triage categories."""
       from mailroom.setup.provisioner import run_setup
       exit_code = run_setup(apply=apply, ui_guide=ui_guide)
       sys.exit(exit_code)
   ```

2. Create `tests/test_provisioner.py` with unit tests. Use monkeypatch to mock client methods.

   a. **test_plan_resources_all_exist**: Mock jmap.call() to return all required mailboxes. Mock carddav.list_groups() to return all required groups. Assert all ResourceActions have status "exists".

   b. **test_plan_resources_some_missing**: Mock responses where Feed mailbox and Feed group are missing. Assert those actions have status "create", others have "exists".

   c. **test_apply_resources_creates_missing**: Start with a plan containing "create" actions. Mock jmap.create_mailbox and carddav.create_group to succeed. Assert statuses become "created".

   d. **test_apply_resources_handles_failure**: Mock create_mailbox to raise RuntimeError. Assert status becomes "failed" with error message.

   e. **test_apply_resources_skips_children_on_parent_failure**: Create a plan where a parent mailbox has status "failed". Assert child mailboxes get status "skipped" with error "parent failed".

   f. **test_plan_resources_categorizes_correctly**: With default categories, verify that Action Labels contain @ToImbox, @ToFeed etc., Mailboxes contain Feed, Inbox, Screener etc., Contact Groups contain Imbox, Feed etc.

   g. **test_reporting_dry_run_output** (optional but valuable): Call print_plan() with a mixed list of actions, capture stdout, verify format includes section headers, status symbols, and summary line.

   Use fixtures: Create a `mock_settings` fixture that returns a `MailroomSettings` with test env vars (MAILROOM_JMAP_TOKEN=test). Create mock JMAP/CardDAV clients with connect/call/list_groups methods stubbed.
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run pytest tests/test_provisioner.py -x -v</automated>
  </verify>
  <done>
    - CLI setup command wired to real provisioner (stub removed)
    - Unit tests cover: all-exist, some-missing, create success, create failure, parent-child skip, categorization
    - All tests pass including existing 211+
    - `mailroom setup` works end-to-end with mocked clients in tests
  </done>
</task>

</tasks>

<verification>
```bash
# All tests pass
cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run pytest tests/ -x -v

# CLI integration
uv run python -m mailroom setup --help

# Import check
uv run python -c "from mailroom.setup.provisioner import run_setup; print('ok')"
```
</verification>

<success_criteria>
- `mailroom setup` (dry-run) shows terraform-style plan of resources with exists/create statuses
- `mailroom setup --apply` creates missing resources and reports results
- Pre-flight connectivity check fails clearly on bad credentials
- Idempotent: second --apply run shows all "exists"
- Parent failure cascades to child "skipped" status
- Exit code 0 for success, 1 for any failure
- Three resource groups displayed: Mailboxes, Action Labels, Contact Groups
- Summary line with counts
</success_criteria>

<output>
After completion, create `.planning/phases/07-setup-script/07-02-SUMMARY.md`
</output>

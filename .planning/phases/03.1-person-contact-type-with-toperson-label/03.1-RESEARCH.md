# Phase 3.1: Person Contact Type with @ToPerson Label - Research

**Researched:** 2026-02-25
**Domain:** CardDAV contact types (company vs person), vCard field mapping, name parsing, JMAP label workflow extension
**Confidence:** HIGH

## Summary

This phase extends the existing triage pipeline to differentiate between company and person contacts. The current `create_contact` method creates all contacts as person-type (FN + N with given name). This must change: the default for all existing triage labels (@ToImbox, @ToFeed, @ToPaperTrail, @ToJail) becomes company-type (FN + ORG, empty N), while a new @ToPerson label creates person-type contacts with properly parsed first/last names.

The implementation touches three layers: (1) config -- add @ToPerson label, @MailroomWarning label, and `warnings_enabled` toggle; (2) CardDAV client -- split `create_contact` into company vs person variants with name parsing; (3) workflow -- route @ToPerson through person-type creation, apply @MailroomWarning on name mismatches for existing contacts.

All changes build on existing patterns (config env vars, label-to-group mapping, conflict detection, startup validation). The nameparser library (v1.1.3) handles name parsing with zero custom logic needed. vobject already supports both ORG and empty N fields natively -- verified by running actual serialization (see Code Examples).

**Primary recommendation:** Use `nameparser.HumanName` for first/last name parsing, add it as a production dependency. Extend `create_contact` with a `contact_type` parameter (or split into two methods) to differentiate company vs person vCard construction. Add @ToPerson to `triage_labels` and `label_to_group_mapping` as a peer of @ToImbox (same group/destination, different contact type).

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions
- **Company contacts (default for @ToImbox, @ToFeed, @ToPaperTrail, @ToJail):**
  - `FN` = display name (required by CardDAV)
  - `ORG` = display name (same value as FN)
  - `N` = empty (this is what makes Fastmail render it as a company)
  - `EMAIL` = sender email
- **Person contacts (@ToPerson only):**
  - `FN` = display name
  - `N` = first/last parsed from display name via a name parsing library
  - No `ORG` field
  - `EMAIL` = sender email
- Verified via CardDAV: Fastmail requires FN but accepts empty N + ORG to display as company
- **NOTE field behavior:**
  - New contacts: "Added by Mailroom on {date}"
  - Existing contacts (upsert): "Updated by Mailroom on {date}"
  - If existing note is present: append Mailroom note below with empty line separator (never overwrite)
- **@ToPerson label:**
  - Label name: `@ToPerson`
  - Imbox-only -- no person variants for other destinations
  - Routes to the same Imbox contact group and Inbox mailbox as @ToImbox
  - Only difference from @ToImbox: creates person-type contact fields instead of company-type
  - Conflicts with @ToImbox -- if both labels appear on the same sender, flag as @MailroomError (ambiguous person vs company intent)
  - Also conflicts with @ToFeed, @ToPaperTrail, @ToJail (same as existing conflict detection)
- **Name parsing:**
  - Use a name parsing library (researcher evaluates options -- not locked to a specific library)
  - Single-word display names -> given name only, family empty
  - No display name (empty or just email) -> use email prefix as given name, family empty
- **Existing contact upsert behavior:**
  - Existing contacts are never modified regardless of label -- only added to the target group
  - The company/person field logic only applies when creating new contacts
  - When @ToPerson encounters an existing contact with different name fields: process normally but apply @MailroomWarning
- **@MailroomWarning label:**
  - General-purpose warning label (not limited to name mismatches)
  - Processing continues normally -- warning is a non-blocking nudge to check logs
  - Log entry explains what was detected
  - Configurable via `MAILROOM_WARNINGS_ENABLED` env var (default: true)
  - Startup validation: when enabled, verify @MailroomWarning label exists in Fastmail at startup (fail fast if missing, same as other labels)

### Claude's Discretion
- Spacing between existing note and Mailroom note (1 vs 2 blank lines)
- Specific name parsing library choice (after researcher evaluates)
- Log message formatting for warnings
- Whether @MailroomWarning needs additional Fastmail config (sublabel structure, etc.)

### Deferred Ideas (OUT OF SCOPE)
None -- discussion stayed within phase scope
</user_constraints>

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| CDAV-03 (extended) | Service can create a new contact vCard for a sender -- now with company vs person type | vobject supports both ORG field and empty N natively (verified). Name() constructor with no args produces `N:;;;;`. ORG field set via `card.add('org').value = [name]` (list format). |
| TRIAGE-02 (extended) | For each triaged email: extract sender, create/update contact, assign to group, remove triage label -- now with @ToPerson routing and @MailroomWarning | @ToPerson maps to same Imbox group + Inbox destination as @ToImbox. Conflict detection already handles multi-label senders. @MailroomWarning is additive JMAP label (same pattern as @MailroomError). |
</phase_requirements>

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| nameparser | 1.1.3 | Parse display names into first/last/middle components | De facto Python name parser, 1.1M+ downloads/month on PyPI, zero dependencies, rule-based (no ML overhead). Handles prefixes ("van der"), suffixes ("III"), compound last names ("Smith-Jones"). |
| vobject | >=0.9.9 | vCard construction (already a dependency) | Already used for all contact operations. Natively supports ORG (list), empty Name(), and Name(given=, family=). |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| pydantic-settings | (existing) | Config for new env vars | MAILROOM_LABEL_TO_PERSON, MAILROOM_LABEL_MAILROOM_WARNING, MAILROOM_WARNINGS_ENABLED |
| structlog | (existing) | Warning log entries | Log name mismatch details when @MailroomWarning applied |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| nameparser | probablepeople | CRF-based ML, heavier, better for messy data but overkill for clean display names from email From headers |
| nameparser | Manual str.split() | Fails on prefixes ("Dr."), compound last names ("van der Berg"), suffixes ("III"). Name parsing is deceptively complex. |

**Installation:**
```bash
uv add nameparser
```

## Architecture Patterns

### Recommended Changes by Layer

```
src/mailroom/
  core/config.py          # Add: label_to_person, label_mailroom_warning, warnings_enabled
                          # Update: triage_labels, label_to_group_mapping, contact_groups (no change needed for groups)
  clients/carddav.py      # Update: create_contact() to support company vs person type
                          # Update: upsert_contact() NOTE handling + return name-mismatch signal
  workflows/screener.py   # Update: _process_sender() to detect contact type from label + apply warning
```

### Pattern 1: Contact Type Routing via Label Mapping
**What:** Add a `contact_type` key to `label_to_group_mapping` entries
**When to use:** When determining whether to create company or person contact
**Example:**
```python
# In config.py - label_to_group_mapping
self.label_to_person: {
    "group": self.group_imbox,
    "destination": self.group_imbox,
    "destination_mailbox": "Inbox",
    "contact_type": "person",  # NEW key
},
self.label_to_imbox: {
    "group": self.group_imbox,
    "destination": self.group_imbox,
    "destination_mailbox": "Inbox",
    "contact_type": "company",  # NEW key (default for all existing labels)
},
```

### Pattern 2: Company vCard Construction (Default)
**What:** Build vCard with FN + ORG + empty N (no first/last)
**When to use:** For all labels except @ToPerson
**Example:**
```python
# Verified working via actual vobject serialization
card = vobject.vCard()
card.add("uid").value = contact_uid
card.add("fn").value = name  # display name
card.add("n").value = vobject.vcard.Name()  # empty N -> "N:;;;;"
card.add("org").value = [name]  # ORG expects a list
email_prop = card.add("email")
email_prop.value = email
email_prop.type_param = "INTERNET"
# Produces: FN:Acme Corp, N:;;;;, ORG:Acme Corp
```

### Pattern 3: Person vCard Construction (@ToPerson)
**What:** Build vCard with FN + N(given, family) + no ORG
**When to use:** Only for @ToPerson label
**Example:**
```python
from nameparser import HumanName

parsed = HumanName(display_name)
card = vobject.vCard()
card.add("uid").value = contact_uid
card.add("fn").value = display_name
card.add("n").value = vobject.vcard.Name(
    given=parsed.first,
    family=parsed.last,
)
# No ORG field
# "Jane Smith" -> FN:Jane Smith, N:Smith;Jane;;;
# "Jane" -> FN:Jane, N:;Jane;;;  (family empty)
```

### Pattern 4: @MailroomWarning Application (Same as @MailroomError Pattern)
**What:** Add @MailroomWarning label to emails via JMAP patch + log warning
**When to use:** When @ToPerson encounters existing contact with different name
**Example:**
```python
# Same JMAP pattern as _apply_error_label
warning_id = self._mailbox_ids[self._settings.label_mailroom_warning]
self._jmap.call([
    ["Email/set", {
        "accountId": self._jmap.account_id,
        "update": {
            email_id: {f"mailboxIds/{warning_id}": True}
        },
    }, "w0"]
])
log.warning("name_mismatch", existing_name="J. Smith", email_name="John Smith")
```

### Anti-Patterns to Avoid
- **Modifying existing contacts for type conversion:** The user explicitly decided existing contacts are never modified. Only new contacts get company/person field logic. Existing contacts just get added to the group.
- **Hand-rolling name parsing:** Even simple `str.split(" ", 1)` fails on "Dr. John Q. Adams III" or "John van der Berg". Use nameparser.
- **Separate upsert methods for company/person:** The upsert orchestration (search -> create-or-update -> add-to-group) is the same regardless of type. Only `create_contact` needs the type distinction.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Name parsing (first/last from display name) | str.split(), regex | `nameparser.HumanName` | Handles prefixes ("Dr."), suffixes ("III"), compound names ("van der Berg"), hyphenated names ("Smith-Jones"). 15+ edge cases. |
| vCard field serialization | Manual string concatenation | `vobject.vCard()` + `.add()` | Already used throughout. Handles escaping, line folding, semicolons in N field. |
| Label-based JMAP operations | Custom HTTP calls | Existing `JMAPClient.call()` with Email/set | Same pattern as @MailroomError. Proven working. |

**Key insight:** The only genuinely new code in this phase is (1) the name parsing call (one line with nameparser), (2) the vCard field branching in create_contact (ORG vs N), and (3) the warning label application (copy of error label pattern). Everything else is config and wiring.

## Common Pitfalls

### Pitfall 1: ORG Field Format is a List
**What goes wrong:** Setting `card.add('org').value = "Company Name"` instead of `["Company Name"]`
**Why it happens:** Most vCard fields are strings, but ORG is a structured field (organization, department, sub-dept) per RFC 2426.
**How to avoid:** Always pass ORG as a list: `card.add('org').value = [name]`
**Warning signs:** vobject may serialize incorrectly or Fastmail may not render the company icon.

### Pitfall 2: Empty N Serialization
**What goes wrong:** Omitting the N field entirely instead of setting it to empty.
**Why it happens:** Developer assumes "empty" means "absent".
**How to avoid:** vCard 3.0 requires N field. Use `vobject.vcard.Name()` which serializes to `N:;;;;` (all components empty).
**Warning signs:** vCard validation failures, Fastmail rejecting the PUT.

### Pitfall 3: nameparser Single-Word Names
**What goes wrong:** Assuming `HumanName("Jane").last` returns something useful.
**Why it happens:** With only one word, nameparser puts it in `first`, leaves `last` as empty string `""`.
**How to avoid:** This is actually correct per the user's decision: "Single-word display names -> given name only, family empty". No special handling needed.
**Warning signs:** None -- this is expected behavior. Verified: `HumanName("Jane") -> first='Jane', last=''`.

### Pitfall 4: @ToPerson + @ToImbox Conflict Detection
**What goes wrong:** Both @ToPerson and @ToImbox route to Imbox, so naive conflict detection might not flag them.
**Why it happens:** Conflict detection currently checks for "different labels" but both map to the same group.
**How to avoid:** Conflict detection already works correctly -- it checks for `len(labels) > 1`, not for different groups. Since @ToPerson and @ToImbox are different label names, they will be detected as a conflict.
**Warning signs:** Two labels on same sender with different contact type intent, silently picking one.

### Pitfall 5: NOTE Field Append vs Overwrite
**What goes wrong:** Overwriting existing notes when updating contacts.
**Why it happens:** Current code already has merge-cautious behavior for empty notes, but the user wants a new behavior: append "Updated by Mailroom" to existing notes.
**How to avoid:** Check if note exists. If yes, append with separator. If no, set "Added by Mailroom". Never overwrite.
**Warning signs:** Existing personal notes disappearing after Mailroom processes a sender.

### Pitfall 6: @MailroomWarning Startup Validation Conditional
**What goes wrong:** Failing startup when @MailroomWarning label doesn't exist in Fastmail, even though warnings are disabled.
**Why it happens:** Adding @MailroomWarning to `triage_labels` unconditionally would require the Fastmail label even when not needed.
**How to avoid:** Only validate @MailroomWarning existence when `warnings_enabled` is True. It's NOT a triage label -- it's a status label like @MailroomError. Add it to `resolve_mailboxes` conditionally.
**Warning signs:** Users who haven't created the label yet getting startup failures despite not wanting warnings.

## Code Examples

Verified patterns from actual execution and codebase analysis:

### Company vCard Serialization (Verified)
```python
# Verified output from actual vobject serialization:
# BEGIN:VCARD
# VERSION:3.0
# UID:test-uid
# EMAIL;TYPE=INTERNET:info@acme.com
# FN:Acme Corp
# N:;;;;
# ORG:Acme Corp
# END:VCARD

card = vobject.vCard()
card.add("uid").value = contact_uid
card.add("fn").value = display_name
card.add("n").value = vobject.vcard.Name()      # Empty N -> "N:;;;;"
card.add("org").value = [display_name]           # ORG is a list
email_prop = card.add("email")
email_prop.value = email
email_prop.type_param = "INTERNET"
card.add("note").value = f"Added by Mailroom on {date.today().isoformat()}"
```

### Person vCard Serialization (Verified)
```python
# Verified output from actual vobject serialization:
# BEGIN:VCARD
# VERSION:3.0
# UID:test-uid-2
# EMAIL;TYPE=INTERNET:jane@example.com
# FN:Jane Smith
# N:Smith;Jane;;;
# END:VCARD

from nameparser import HumanName
parsed = HumanName(display_name)  # "Jane Smith"

card = vobject.vCard()
card.add("uid").value = contact_uid
card.add("fn").value = display_name
card.add("n").value = vobject.vcard.Name(
    given=parsed.first,    # "Jane"
    family=parsed.last,    # "Smith"
)
# No ORG field for person contacts
email_prop = card.add("email")
email_prop.value = email
email_prop.type_param = "INTERNET"
card.add("note").value = f"Added by Mailroom on {date.today().isoformat()}"
```

### nameparser Behavior for Edge Cases (Verified)
```python
from nameparser import HumanName

# Standard two-word name
HumanName("Jane Smith")        # first='Jane', last='Smith'

# Single word -> given only (matches user decision)
HumanName("Jane")              # first='Jane', last=''

# Complex name with prefix and suffix
HumanName("Dr. John Q. Adams III")  # first='John', last='Adams', middle='Q.'

# Compound last name
HumanName("John van der Berg") # first='John', last='van der Berg'

# Hyphenated last name
HumanName("Jane Smith-Jones")  # first='Jane', last='Smith-Jones'

# Empty string -> all empty (handled at call site)
HumanName("")                  # first='', last=''

# Email address as name (edge case when no display name)
# Should use email prefix instead (handled before nameparser call)
HumanName("newsletter@company.com")  # first='newsletter@company.com', last=''
```

### NOTE Field Append Pattern
```python
from datetime import date

existing_note = card.contents.get("note", [])
mailroom_note = f"Updated by Mailroom on {date.today().isoformat()}"

if existing_note and existing_note[0].value.strip():
    # Append below existing note with blank line separator
    card.note.value = f"{existing_note[0].value}\n\n{mailroom_note}"
else:
    # No existing note -- set fresh
    card.add("note").value = f"Added by Mailroom on {date.today().isoformat()}"
```

### Config Extension Pattern
```python
# In MailroomSettings (config.py)
label_to_person: str = "@ToPerson"
label_mailroom_warning: str = "@MailroomWarning"
warnings_enabled: bool = True

@property
def triage_labels(self) -> list[str]:
    return [
        self.label_to_imbox,
        self.label_to_feed,
        self.label_to_paper_trail,
        self.label_to_jail,
        self.label_to_person,  # NEW
    ]

@property
def label_to_group_mapping(self) -> dict[str, dict[str, str]]:
    return {
        # ... existing entries with "contact_type": "company" ...
        self.label_to_person: {
            "group": self.group_imbox,
            "destination": self.group_imbox,
            "destination_mailbox": "Inbox",
            "contact_type": "person",
        },
    }
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| All contacts as person-type (N with given name) | Company-type default (ORG + empty N) | Phase 3.1 | Fastmail displays company icon for organizations |
| No name parsing | nameparser.HumanName for @ToPerson | Phase 3.1 | Proper first/last split in vCard N field |
| Only @MailroomError for issues | @MailroomWarning for non-blocking alerts | Phase 3.1 | User gets nudge without blocking processing |

**Deprecated/outdated:**
- The current `create_contact` method always sets `N` with `given=name`. After this phase, that behavior only applies to @ToPerson; all other labels set `N` to empty and add `ORG`.

## Open Questions

1. **Name mismatch detection threshold**
   - What we know: User wants @MailroomWarning when @ToPerson encounters an existing contact with "different name fields"
   - What's unclear: Exact comparison -- is it FN mismatch? N field mismatch? Case-sensitive?
   - Recommendation: Compare the display name from the email's From header against the existing contact's FN field (case-insensitive, stripped). This is the simplest meaningful check. Log both values so the user can assess.

2. **@MailroomWarning as a Fastmail label (mailbox)**
   - What we know: @MailroomError is a JMAP mailbox/label that gets added to emails. @MailroomWarning follows the same pattern.
   - What's unclear: Does the user need to create @MailroomWarning in Fastmail as a mailbox before running Mailroom?
   - Recommendation: Yes -- same pattern as @MailroomError. Validate at startup (when `warnings_enabled=True`). Document in human test prerequisites.

3. **Whether `create_contact` signature should change or split**
   - What we know: Currently `create_contact(email, display_name)`. Needs to support company vs person.
   - What's unclear: Add a `contact_type` parameter, or create two methods?
   - Recommendation: Add a `contact_type: str = "company"` parameter. Keeps one method with a clean branch. Two methods would duplicate 80% of the code (UID generation, email, note, PUT).

## Sources

### Primary (HIGH confidence)
- vobject actual execution -- tested company vCard (ORG + empty N) and person vCard (N with given/family) serialization directly
- nameparser actual execution -- tested all edge cases (single word, compound names, empty string, email-as-name) with v1.1.3
- Codebase analysis -- read all source files, tests, and human tests to understand existing patterns

### Secondary (MEDIUM confidence)
- [nameparser PyPI](https://pypi.org/project/nameparser/) -- v1.1.3, latest stable
- [nameparser docs](https://nameparser.readthedocs.io/) -- HumanName class API
- [vobject PyPI](https://pypi.org/project/vobject/) -- ORG field as list, Name class constructor
- [vCard 3.0 RFC 2426](https://www.ietf.org/rfc/rfc2426.txt) -- N and ORG field specifications
- [vCard company contact pattern](https://www.evenx.com/vcard-3-0-format-specification) -- FN + ORG + empty N for organization contacts

### Tertiary (LOW confidence)
- None -- all findings verified with primary sources or actual execution

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- nameparser verified via execution, vobject already in use
- Architecture: HIGH -- extends proven patterns (config, label mapping, conflict detection, JMAP label ops)
- Pitfalls: HIGH -- all pitfalls verified with actual code/execution, not hypothetical

**Research date:** 2026-02-25
**Valid until:** 2026-03-25 (stable domain, no fast-moving dependencies)

---
phase: 01-foundation-and-jmap-client
plan: 03
type: tdd
wave: 3
depends_on:
  - 01-02
files_modified:
  - src/mailroom/clients/jmap.py
  - tests/test_jmap_client.py
autonomous: true
requirements:
  - JMAP-03
  - JMAP-04
  - JMAP-05
  - JMAP-06
  - JMAP-07
  - JMAP-08

must_haves:
  truths:
    - "The service can query emails in a specific mailbox and get their IDs"
    - "The service extracts the sender email address from a queried email"
    - "The service can remove a triage label from a single email without affecting other labels"
    - "The service can query all Screener emails from a specific sender"
    - "The service can batch-move emails: remove source label, add destination label in one operation"
    - "When destination is Imbox, the Inbox label is also added to swept emails"
    - "Large result sets are handled via pagination (not silently truncated)"
  artifacts:
    - path: "src/mailroom/clients/jmap.py"
      provides: "Email query, sender extraction, label removal, batch move, Inbox re-label methods"
      exports: ["JMAPClient"]
      min_lines: 150
    - path: "tests/test_jmap_client.py"
      provides: "Tests for all email operations using mocked httpx responses"
      min_lines: 150
  key_links:
    - from: "src/mailroom/clients/jmap.py query_emails()"
      to: "Email/query JMAP method"
      via: "filter by inMailbox and optionally from"
      pattern: "Email/query"
    - from: "src/mailroom/clients/jmap.py get_email_senders()"
      to: "Email/get JMAP method"
      via: "properties: ['from'] to extract sender"
      pattern: "Email/get"
    - from: "src/mailroom/clients/jmap.py remove_label()"
      to: "Email/set JMAP method"
      via: "patch syntax mailboxIds/{id}: null"
      pattern: "mailboxIds/.*null"
    - from: "src/mailroom/clients/jmap.py batch_move_emails()"
      to: "Email/set JMAP method"
      via: "patch syntax to remove source + add destination labels in one call"
      pattern: "Email/set"
---

<objective>
Implement and test all JMAP email operations: querying, sender extraction, label removal, and batch email moves with the Imbox/Inbox special case. Built via TDD on top of the JMAP client from Plan 02.

Purpose: These are the core email manipulation operations the triage workflow needs. Every triage action (sweep sender's emails, relabel, remove triage tag) maps to one of these methods.
Output: A complete JMAP client with all email operations tested against mocked httpx responses.
</objective>

<execution_context>
@/Users/flo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/flo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-and-jmap-client/01-CONTEXT.md
@.planning/phases/01-foundation-and-jmap-client/01-RESEARCH.md
@.planning/phases/01-foundation-and-jmap-client/01-02-SUMMARY.md
</context>

<feature>
  <name>JMAP Email Query, Extraction, and Move Operations</name>
  <files>src/mailroom/clients/jmap.py, tests/test_jmap_client.py</files>
  <behavior>
    **Email Query by Mailbox (JMAP-03):**
    - Input: mailbox_id (str), optional limit (int)
    - Action: Email/query with filter inMailbox
    - Output: list of email ID strings
    - Pagination: If total > len(returned ids), fetch additional pages using position offset

    Cases:
    - Mailbox with 5 emails, limit=100 -> returns 5 IDs
    - Empty mailbox -> returns []
    - Mailbox with 150 emails, limit=100 -> paginates, returns all 150 IDs

    **Sender Extraction (JMAP-04):**
    - Input: list of email IDs
    - Action: Email/get with properties=["id", "from"]
    - Output: dict mapping email_id -> sender email address (str)
    - Edge: "from" is array of {name, email} -- extract first element's email field

    Cases:
    - Single email -> {"emailId": "sender@example.com"}
    - Multiple emails from same sender -> all map to same address
    - Email with display name "Alice <alice@example.com>" -> extracts "alice@example.com"

    **Query Emails from Sender in Mailbox (JMAP-06):**
    - Input: mailbox_id (str), sender_email (str)
    - Action: Email/query with filter {inMailbox, from: sender_email}
    - Output: list of email ID strings (with pagination)
    - Note: Fastmail's `from` filter may be substring match. For Phase 1, trust the filter. If imprecise, Phase 3 can add client-side filtering.

    Cases:
    - Sender has 3 emails in Screener -> returns 3 IDs
    - Sender has 0 emails in Screener -> returns []

    **Remove Triage Label (JMAP-05):**
    - Input: email_id (str), label_mailbox_id (str)
    - Action: Email/set update with patch `mailboxIds/{label_mailbox_id}: null`
    - Output: None (success) or raise on error
    - Safety: Only removes the one label. Does NOT replace entire mailboxIds map.

    Cases:
    - Email has [Screener, @ToImbox] labels -> remove @ToImbox -> email has [Screener]
    - Email/set returns error -> raise with descriptive message

    **Batch Move Emails (JMAP-07):**
    - Input: email_ids (list[str]), remove_mailbox_id (str), add_mailbox_ids (list[str])
    - Action: Email/set with update map, each email gets patch: remove source, add destinations
    - Output: None (success) or raise on error
    - Batching: Process in chunks of 100 email IDs per Email/set call (conservative, under Fastmail's maxObjectsInSet)

    Cases:
    - 5 emails, remove Screener, add Feed -> single Email/set with 5 entries
    - 150 emails -> two Email/set calls (100 + 50)
    - Email/set partial failure (some not updated) -> raise with failed IDs

    **Imbox Special Case - Add Inbox Label (JMAP-08):**
    - Input: email_ids, screener_id, imbox_id, inbox_id
    - Action: Same batch move, but add_mailbox_ids includes both imbox_id AND inbox_id
    - Output: Emails have Screener removed, Imbox added, Inbox added

    Cases:
    - Destination is Imbox -> patch includes mailboxIds/{inbox_id}: true
    - Destination is Feed -> patch does NOT include Inbox label

    This is NOT a separate method -- it's handled by the caller passing inbox_id in add_mailbox_ids. The batch_move_emails method is generic. Test that the correct patch is built when inbox_id is included.
  </behavior>
  <implementation>
    Extend `src/mailroom/clients/jmap.py` (from Plan 02) with these methods on JMAPClient:

    ```python
    def query_emails(self, mailbox_id: str, sender: str | None = None, limit: int = 100) -> list[str]:
        """Query email IDs in a mailbox, optionally filtered by sender.
        Handles pagination automatically."""
        # Email/query with filter, paginate if total > returned
        # Covers JMAP-03 and JMAP-06

    def get_email_senders(self, email_ids: list[str]) -> dict[str, str]:
        """Get sender email address for each email ID.
        Returns {email_id: sender_email}."""
        # Email/get with properties=["id", "from"]
        # Extract first from[].email
        # Covers JMAP-04

    def remove_label(self, email_id: str, mailbox_id: str) -> None:
        """Remove a single mailbox label from an email."""
        # Email/set with patch mailboxIds/{mailbox_id}: null
        # Covers JMAP-05

    def batch_move_emails(self, email_ids: list[str], remove_mailbox_id: str, add_mailbox_ids: list[str]) -> None:
        """Batch-move emails: remove source label, add destination label(s).
        Processes in chunks of 100. Caller includes inbox_id in add_mailbox_ids for Imbox destination."""
        # Build update map with patch syntax for each email
        # Chunk into batches of 100
        # Covers JMAP-07 and JMAP-08
    ```

    **Pitfall awareness (from research):**
    - Use patch syntax (`mailboxIds/{id}: null` / `true`), never replace entire mailboxIds map (Pitfall: email must always belong to at least one mailbox)
    - Pagination: check `total` vs `len(ids)` in Email/query response; fetch more pages with `position` offset
    - Batching: chunk at 100 per Email/set call (conservative under 500 maxObjectsInSet minimum)
    - Result reference chaining is NOT used in Phase 1 -- separate calls are clearer and easier to debug

    **Use `pytest-httpx` for all mocking.** Each test sets up httpx mock responses matching the expected JMAP request/response format. No live API calls.
  </implementation>
</feature>

<verification>
```bash
uv run pytest tests/test_jmap_client.py -v
uv run ruff check src/mailroom/clients/jmap.py tests/test_jmap_client.py
```

All tests pass. Test count for this plan should add at least 8 new tests (query basic, query empty, query paginated, get senders, query by sender, remove label, batch move, batch move with inbox label).

Run full suite to verify no regressions:
```bash
uv run pytest tests/ -v
```
</verification>

<success_criteria>
- query_emails() returns email IDs from mocked Email/query, handles pagination
- get_email_senders() extracts sender addresses from mocked Email/get response
- query_emails() with sender parameter filters by sender (JMAP-06)
- remove_label() builds correct patch syntax for label removal
- batch_move_emails() builds correct patch for source removal + destination addition
- batch_move_emails() with inbox_id in add_mailbox_ids adds Inbox label (JMAP-08)
- batch_move_emails() chunks large lists into batches of 100
- All tests pass, ruff check clean, full test suite green
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-jmap-client/01-03-SUMMARY.md`
</output>

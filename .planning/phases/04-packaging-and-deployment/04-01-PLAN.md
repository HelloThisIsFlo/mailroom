---
phase: 04-packaging-and-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/mailroom/__main__.py
  - Dockerfile
  - .dockerignore
autonomous: true
requirements:
  - DEPLOY-01

must_haves:
  truths:
    - "python -m mailroom starts the polling loop and logs service_started"
    - "SIGTERM causes the service to finish its current cycle and exit cleanly with service_stopped"
    - "GET /healthz returns 200 with status ok while the service is running"
    - "10+ consecutive poll failures cause the service to crash with exit code 1"
    - "Startup failures (missing config, auth failure) crash immediately"
    - "docker build produces a slim image that starts the polling loop"
  artifacts:
    - path: "src/mailroom/__main__.py"
      provides: "Polling loop entry point with signal handling, health endpoint, tiered error handling"
      min_lines: 80
    - path: "Dockerfile"
      provides: "Multi-stage build with uv for slim Python image"
      min_lines: 25
    - path: ".dockerignore"
      provides: "Excludes dev files, tests, and planning from Docker context"
      min_lines: 5
  key_links:
    - from: "src/mailroom/__main__.py"
      to: "mailroom.workflows.screener.ScreenerWorkflow"
      via: "import and poll() call in main loop"
      pattern: "workflow\\.poll\\(\\)"
    - from: "src/mailroom/__main__.py"
      to: "mailroom.core.config.MailroomSettings"
      via: "config loading at startup"
      pattern: "MailroomSettings\\(\\)"
    - from: "Dockerfile"
      to: "src/mailroom/__main__.py"
      via: "CMD python -m mailroom"
      pattern: 'CMD.*python.*-m.*mailroom'
---

<objective>
Create the main polling loop entry point and Docker image for Mailroom.

Purpose: Provide the long-lived service entry point (`python -m mailroom`) with graceful shutdown, health probes, and tiered error handling, packaged in a slim Docker image using multi-stage uv build.

Output: `src/mailroom/__main__.py` (entry point), `Dockerfile` (multi-stage build), `.dockerignore` (context exclusions)
</objective>

<execution_context>
@/Users/flo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/flo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-packaging-and-deployment/04-RESEARCH.md

@src/mailroom/core/config.py
@src/mailroom/core/logging.py
@src/mailroom/workflows/screener.py
@src/mailroom/clients/jmap.py
@src/mailroom/clients/carddav.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create __main__.py polling loop with health endpoint and signal handling</name>
  <files>src/mailroom/__main__.py</files>
  <action>
Create `src/mailroom/__main__.py` implementing the full polling service entry point. Follow the research patterns exactly:

**Startup sequence (crash on failure):**
1. Load config: `MailroomSettings()` — crashes on missing required vars (pydantic ValidationError)
2. Configure logging: `configure_logging(settings.log_level)`
3. Connect JMAP client: `JMAPClient(token=settings.jmap_token)` then `.connect()`
4. Connect CardDAV client: `CardDAVClient(username=settings.carddav_username, password=settings.carddav_password)` then `.connect()`
5. Resolve mailboxes: `jmap.resolve_mailboxes(settings.required_mailboxes)` — crashes if any mailbox missing
6. Validate groups: `carddav.validate_groups(settings.contact_groups)` — crashes if any group missing
7. Build workflow: `ScreenerWorkflow(jmap, carddav, settings, mailbox_ids)`
8. Start health server on port 8080 (daemon thread)
9. Enter polling loop

**Health endpoint (stdlib http.server on daemon thread):**
- `GET /healthz` returns 200 with JSON `{"status": "ok", "last_poll_age_seconds": N}` when healthy
- Returns 503 with `{"status": "unhealthy", ...}` when last successful poll is older than 2x poll_interval
- Treat `last_successful_poll == 0.0` (just started, no poll yet) as healthy (return 200)
- Suppress default access logs (override `log_message`)
- Use `http.server.ThreadingHTTPServer` on `("0.0.0.0", 8080)` in a daemon thread
- Use class-level attributes for shared state with polling loop (`last_successful_poll`, `poll_interval`)

**Polling loop with tiered error handling:**
- Use `threading.Event` for shutdown signal — NOT `time.sleep()` (Event.wait wakes immediately on SIGTERM)
- Register SIGTERM and SIGINT handlers that set the shutdown event
- On successful poll: reset consecutive_failures to 0, update HealthHandler.last_successful_poll to `time.time()`
- On poll exception: increment consecutive_failures, log with `exc_info=True`
- If consecutive_failures >= 10 (MAX_CONSECUTIVE_FAILURES constant): log critical and `sys.exit(1)`
- After each poll/failure: `shutdown_event.wait(settings.poll_interval)` — wakes on signal or timeout
- After loop exits: log `service_stopped` with reason

**Constants:**
- `MAX_CONSECUTIVE_FAILURES = 10`
- `HEALTH_PORT = 8080`

**Module pattern:** `def main() -> None:` with `if __name__ == "__main__": main()` guard.

Use structlog for all logging with `component="main"` binding. Import from project modules:
- `from mailroom.clients.carddav import CardDAVClient`
- `from mailroom.clients.jmap import JMAPClient`
- `from mailroom.core.config import MailroomSettings`
- `from mailroom.core.logging import configure_logging`
- `from mailroom.workflows.screener import ScreenerWorkflow`
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && python -c "import mailroom.__main__; print('import ok')"</automated>
    <manual>Verify __main__.py has main() function, ShutdownHandler/Event pattern, HealthHandler class, polling loop with tiered errors</manual>
  </verify>
  <done>src/mailroom/__main__.py exists with polling loop, SIGTERM handling via threading.Event, /healthz health endpoint on daemon thread, tiered error handling (startup crash, transient skip, persistent crash at 10 failures), and clean logging</done>
</task>

<task type="auto">
  <name>Task 2: Create Dockerfile and .dockerignore for multi-stage uv build</name>
  <files>Dockerfile, .dockerignore</files>
  <action>
**Dockerfile** — Multi-stage build following the official uv Docker guide:

Stage 1 (builder):
- Base: `python:3.12-slim`
- Copy uv binary: `COPY --from=ghcr.io/astral-sh/uv:latest /uv /uvx /bin/`
- Set `UV_COMPILE_BYTECODE=1` and `UV_LINK_MODE=copy`
- WORKDIR `/app`
- Install dependencies first (cached layer): `RUN --mount=type=cache,target=/root/.cache/uv --mount=type=bind,source=uv.lock,target=uv.lock --mount=type=bind,source=pyproject.toml,target=pyproject.toml uv sync --locked --no-install-project --no-dev --no-editable`
- Copy source: `COPY . /app`
- Install project: `RUN --mount=type=cache,target=/root/.cache/uv uv sync --locked --no-dev --no-editable`

Stage 2 (runtime):
- Base: `python:3.12-slim`
- Create non-root user: `RUN groupadd -r app && useradd -r -d /app -g app -N app`
- Copy venv from builder: `COPY --from=builder --chown=app:app /app/.venv /app/.venv`
- Set `PATH="/app/.venv/bin:$PATH"`
- Switch to app user: `USER app`
- Expose port 8080 (health endpoint)
- CMD: `["python", "-m", "mailroom"]`

**.dockerignore** — Exclude non-build files:
```
.git/
.github/
.planning/
.agents/
.claude/
.env
.env.*
.venv/
.ruff_cache/
.pytest_cache/
__pycache__/
*.pyc
tests/
human-tests/
k8s/
*.md
!README.md
```
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && docker build -t mailroom:test . 2>&1 | tail -5</automated>
    <manual>Verify docker image builds successfully, check image size with docker images mailroom:test</manual>
  </verify>
  <done>Dockerfile builds a slim multi-stage image (~150MB) with non-root user, .dockerignore excludes dev/test/planning files from build context</done>
</task>

</tasks>

<verification>
1. `python -c "import mailroom.__main__"` succeeds (module is importable)
2. `docker build -t mailroom:test .` succeeds (image builds)
3. `docker images mailroom:test --format '{{.Size}}'` shows a slim image (<200MB)
4. Dockerfile uses multi-stage build with non-root user
5. __main__.py has SIGTERM handling, health endpoint, tiered errors, and polling loop
</verification>

<success_criteria>
- __main__.py implements the complete polling service entry point following all locked decisions
- Dockerfile produces a slim image using multi-stage uv build pattern
- Docker image starts the service with `python -m mailroom`
- Health endpoint runs on port 8080 in a daemon thread
- SIGTERM triggers graceful shutdown (finish current cycle, then exit)
</success_criteria>

<output>
After completion, create `.planning/phases/04-packaging-and-deployment/04-01-SUMMARY.md`
</output>

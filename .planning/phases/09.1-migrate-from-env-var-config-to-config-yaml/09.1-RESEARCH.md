# Phase 9.1: Migrate from env var config to config.yaml - Research

**Researched:** 2026-03-01
**Domain:** Configuration management — pydantic-settings YAML source, nested models, K8s ConfigMap volume mount
**Confidence:** HIGH

## Summary

pydantic-settings v2.13.1 (already installed) has built-in `YamlConfigSettingsSource` behind the `pydantic-settings[yaml]` extra (which installs PyYAML). The project currently uses `BaseSettings` with `env_prefix="MAILROOM_"` for all configuration. The migration replaces flat env var fields with nested sub-models (`auth`, `polling`, `triage`, `labels`, `logging`) loaded from `config.yaml`, while keeping 3 auth env vars as the sole env-sourced secrets.

The main technical challenge is not the YAML loading (pydantic-settings handles it natively) but the **migration surface**: 188 field access sites across 22 `.py` files need path changes (e.g., `settings.poll_interval` to `settings.polling.interval`). Tests currently create `MailroomSettings()` via `monkeypatch.setenv`; they must shift to YAML fixture files or constructor kwargs. The K8s deployment changes from `envFrom: configMapRef` to a volume-mounted `config.yaml` file.

**Primary recommendation:** Use pydantic-settings' native `YamlConfigSettingsSource` with `settings_customise_sources` to merge YAML (non-secrets) and env vars (3 auth secrets). No third-party config libraries needed.

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions
- YAML organized by concern: `auth`, `polling`, `triage`, `labels`, `logging` sections
- Nested sub-models in pydantic: `AuthSettings`, `PollingSettings`, `TriageSettings`, `LabelSettings`, `LoggingSettings` composed into `MailroomSettings`
- Access paths change: `settings.jmap_token` → `settings.auth.jmap_token`, `settings.poll_interval` → `settings.polling.interval`, etc.
- Name-only shorthand for triage categories: a plain string (e.g., `- Feed`) is a category with just a name; dict form for overrides (e.g., `- name: Person\n  parent: Imbox`)
- Commented `config.yaml.example` ships with the project — explains each section inline, similar to current `.env.example`
- Config.yaml contains all non-secret behavior settings
- 3 auth env vars survive: `MAILROOM_JMAP_TOKEN`, `MAILROOM_CARDDAV_USERNAME`, `MAILROOM_CARDDAV_PASSWORD` — kept with current flat naming (no double-underscore nesting)
- MailroomSettings merges config.yaml + env vars into one object — code accesses fields uniformly regardless of source
- K8s: Secret resource unchanged (injects 3 env vars); ConfigMap holds config.yaml as file data
- Clean break: no backwards compatibility, no deprecation warnings, no detection of old env vars
- Old non-secret env vars silently ignored
- `.env.example` shrinks to only the 3 auth credential lines
- `k8s/configmap.yaml` changes from individual env var key-value pairs to embedded config.yaml file content
- `k8s/deployment.yaml` changes from `envFrom: configMapRef` to volume mount for config.yaml; keeps `envFrom: secretRef`
- `k8s/secret.yaml.example` unchanged
- Default: look for `config.yaml` in working directory
- Override: `MAILROOM_CONFIG` env var specifies alternate path
- Missing config.yaml: error and exit with clear message pointing to config.yaml.example
- YAML parse errors: fail fast with line-level error messages
- Invalid config values: fail fast with pydantic validation errors
- `mailroom-setup` command reads the same config.yaml as the main service
- Config.yaml structure should match future Helm `values.yaml`

### Claude's Discretion
- YAML parsing library choice (PyYAML vs ruamel.yaml vs pydantic-yaml)
- Exact error message formatting for parse/validation failures
- Internal config loading architecture (custom settings source vs manual YAML load)
- Test migration strategy for the ~40 call sites

### Deferred Ideas (OUT OF SCOPE)
- Helm migration — future phase
- Env var override for ANY config.yaml field (not just secrets) — explicitly not doing this
</user_constraints>

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| pydantic-settings | 2.13.1 (installed) | Settings management with multiple sources | Already the project's config backbone; has native YAML support |
| pydantic-settings[yaml] | 2.13.1 | Installs PyYAML as YAML parser dependency | Official extra from pydantic-settings; brings `YamlConfigSettingsSource` |
| PyYAML | 6.0.2 (via extra) | YAML file parsing | Industry standard; pydantic-settings[yaml] depends on it |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| pydantic | (existing) | Sub-model definitions (`BaseModel`) | Define `PollingSettings`, `TriageSettings`, etc. as `BaseModel` |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| PyYAML (via pydantic-settings[yaml]) | ruamel.yaml | ruamel preserves comments/round-trips but we only read — PyYAML is simpler and officially supported by pydantic-settings |
| PyYAML (via pydantic-settings[yaml]) | pydantic-yaml (3rd party) | Separate project, adds another dependency; pydantic-settings already handles this natively |
| YamlConfigSettingsSource | Manual `yaml.safe_load` + constructor kwargs | Loses pydantic-settings source priority chain, more custom code |

**Recommendation:** Use `pydantic-settings[yaml]` (PyYAML). It is the officially supported path, requires zero custom YAML parsing code, and integrates cleanly with the existing `BaseSettings` pattern.

**Installation:**
```bash
# Change pyproject.toml dependency from:
#   "pydantic-settings",
# to:
#   "pydantic-settings[yaml]",
# Then:
uv sync
```

**Note:** PyYAML is NOT currently in the project virtualenv (only available system-wide). The `[yaml]` extra must be explicitly declared in `pyproject.toml` to ensure it is installed in the venv and Docker builds.

## Architecture Patterns

### Target Config Model Structure

```python
# Source: pydantic-settings official docs + CONTEXT.md decisions
from pydantic import BaseModel, Field
from pydantic_settings import BaseSettings, SettingsConfigDict, YamlConfigSettingsSource, PydanticBaseSettingsSource

class AuthSettings(BaseModel):
    """Auth credentials — populated from env vars, not YAML."""
    jmap_token: str
    carddav_username: str = ""
    carddav_password: str = ""

class PollingSettings(BaseModel):
    interval: int = 60
    debounce_seconds: int = 3

class LabelSettings(BaseModel):
    mailroom_error: str = "@MailroomError"
    mailroom_warning: str = "@MailroomWarning"
    warnings_enabled: bool = True

class LoggingSettings(BaseModel):
    level: str = "info"

class TriageSettings(BaseModel):
    screener_mailbox: str = "Screener"
    categories: list[TriageCategory] = Field(default_factory=_default_categories)

class MailroomSettings(BaseSettings):
    model_config = SettingsConfigDict(
        yaml_file='config.yaml',
        yaml_file_encoding='utf-8',
        env_prefix='MAILROOM_',       # Only affects flat env var fields
    )

    # Nested sections (from YAML)
    polling: PollingSettings = PollingSettings()
    triage: TriageSettings = TriageSettings()
    labels: LabelSettings = LabelSettings()
    logging: LoggingSettings = LoggingSettings()

    # Auth (from env vars — flat, not nested)
    jmap_token: str           # MAILROOM_JMAP_TOKEN
    carddav_username: str = ""  # MAILROOM_CARDDAV_USERNAME
    carddav_password: str = ""  # MAILROOM_CARDDAV_PASSWORD

    @classmethod
    def settings_customise_sources(
        cls,
        settings_cls: type[BaseSettings],
        init_settings: PydanticBaseSettingsSource,
        env_settings: PydanticBaseSettingsSource,
        dotenv_settings: PydanticBaseSettingsSource,
        file_secret_settings: PydanticBaseSettingsSource,
    ) -> tuple[PydanticBaseSettingsSource, ...]:
        return (
            init_settings,
            env_settings,             # env vars (3 auth secrets)
            YamlConfigSettingsSource(settings_cls),  # config.yaml (everything else)
        )
```

### Key Design Decision: Auth Fields Stay Flat on MailroomSettings

The 3 auth env vars (`MAILROOM_JMAP_TOKEN`, `MAILROOM_CARDDAV_USERNAME`, `MAILROOM_CARDDAV_PASSWORD`) remain as **flat top-level fields** on `MailroomSettings`, not nested under an `auth` sub-model. This is because:

1. `env_prefix="MAILROOM_"` with flat fields maps directly to `MAILROOM_JMAP_TOKEN` (desired).
2. Nesting under `AuthSettings` would require `MAILROOM_AUTH__JMAP_TOKEN` with `env_nested_delimiter='__'` — but the user explicitly decided to keep current flat naming.
3. The `auth` section in YAML would be empty/absent (secrets don't go in YAML), which is clean.

Access pattern: `settings.jmap_token` (unchanged), `settings.polling.interval` (new nested path).

### YAML File Discovery

```python
import os
from pathlib import Path

def _resolve_config_path() -> str:
    """Resolve config.yaml path: MAILROOM_CONFIG env var or cwd default."""
    config_path = os.environ.get("MAILROOM_CONFIG", "config.yaml")
    path = Path(config_path)
    if not path.exists():
        raise SystemExit(
            f"Config file not found: {path.resolve()}\n"
            f"Copy config.yaml.example to config.yaml and edit it:\n"
            f"  cp config.yaml.example config.yaml"
        )
    return str(path)
```

This can be wired into `MailroomSettings` by dynamically setting `yaml_file` via `model_config` or by overriding `settings_customise_sources` to pass the resolved path to `YamlConfigSettingsSource(settings_cls, yaml_file=resolved_path)`.

### Name-Only Shorthand for Triage Categories

The user wants `- Feed` (plain string) as shorthand for `- name: Feed`. This requires a **pydantic validator** on `TriageSettings.categories` (or on `MailroomSettings` after model construction):

```python
from pydantic import field_validator

class TriageSettings(BaseModel):
    screener_mailbox: str = "Screener"
    categories: list[TriageCategory] = Field(default_factory=_default_categories)

    @field_validator("categories", mode="before")
    @classmethod
    def normalize_categories(cls, v: list) -> list:
        """Allow plain strings as shorthand: '- Feed' → {'name': 'Feed'}."""
        result = []
        for item in v:
            if isinstance(item, str):
                result.append({"name": item})
            else:
                result.append(item)
        return result
```

### Target config.yaml Structure

```yaml
# config.yaml — Mailroom configuration
# Secrets (JMAP token, CardDAV credentials) are set via environment variables.
# See .env.example for required auth env vars.

polling:
  interval: 60          # Seconds between fallback polls (SSE push is primary)
  debounce_seconds: 3   # SSE event debounce window

triage:
  screener_mailbox: Screener
  categories:
    - name: Imbox
      destination_mailbox: Inbox
    - Feed
    - Paper Trail
    - Jail
    - name: Person
      parent: Imbox
      contact_type: person

labels:
  mailroom_error: "@MailroomError"
  mailroom_warning: "@MailroomWarning"
  warnings_enabled: true

logging:
  level: info
```

### K8s ConfigMap: Embedded config.yaml

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mailroom-config
  namespace: mailroom
data:
  config.yaml: |
    polling:
      interval: 60
      debounce_seconds: 3
    triage:
      screener_mailbox: Screener
      categories:
        - name: Imbox
          destination_mailbox: Inbox
        - Feed
        - Paper Trail
        - Jail
        - name: Person
          parent: Imbox
          contact_type: person
    labels:
      mailroom_error: "@MailroomError"
      mailroom_warning: "@MailroomWarning"
      warnings_enabled: true
    logging:
      level: info
```

### K8s Deployment: Volume Mount

```yaml
spec:
  template:
    spec:
      containers:
        - name: mailroom
          # ... existing config ...
          envFrom:
            # ConfigMap ref REMOVED — config is now a file
            - secretRef:
                name: mailroom-secrets
          volumeMounts:
            - name: config
              mountPath: /app/config.yaml
              subPath: config.yaml
              readOnly: true
      volumes:
        - name: config
          configMap:
            name: mailroom-config
```

### Anti-Patterns to Avoid
- **Nesting auth env vars:** Don't use `env_nested_delimiter='__'` to put secrets under `auth.jmap_token`. Keep them flat for K8s Secret compatibility.
- **Optional config.yaml:** Don't silently fall back to defaults when config.yaml is missing. The user decision is to fail with a clear error message.
- **Dual-source for non-secrets:** Don't allow env vars to override YAML fields. The user explicitly deferred this.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| YAML parsing | Custom `yaml.safe_load` + dict merge | `YamlConfigSettingsSource` | Handles nested models, type coercion, validation automatically |
| Settings source priority | Manual merge logic | `settings_customise_sources` | pydantic-settings' built-in priority chain |
| Config file discovery | Argparse/complex logic | `MAILROOM_CONFIG` env var + `Path.exists()` check | Simple, K8s-friendly (env var for path override) |
| Triage category normalization | Post-load transformation | `field_validator(mode="before")` | Pydantic's validation pipeline handles it cleanly |

**Key insight:** pydantic-settings already supports YAML as a first-class source. The entire YAML loading, parsing, validation, and type coercion pipeline is handled by the library. Custom code is only needed for: (1) config file discovery, (2) name-only shorthand normalization, (3) error formatting.

## Common Pitfalls

### Pitfall 1: PyYAML Not Installed in Venv
**What goes wrong:** `YamlConfigSettingsSource` imports but fails at runtime with `ImportError` because PyYAML is only available system-wide, not in the project venv or Docker image.
**Why it happens:** PyYAML is installed system-wide on the dev machine but not declared in `pyproject.toml`. The current `pydantic-settings` dependency doesn't include the `[yaml]` extra.
**How to avoid:** Change `pyproject.toml` from `"pydantic-settings"` to `"pydantic-settings[yaml]"`, then `uv sync` and rebuild Docker image.
**Warning signs:** Tests pass locally (system PyYAML) but Docker build fails.

### Pitfall 2: env_prefix Interaction with Nested Models
**What goes wrong:** Setting `env_prefix="MAILROOM_"` with nested sub-models causes pydantic-settings to look for `MAILROOM_POLLING__INTERVAL` (double-underscore) for nested fields when `env_nested_delimiter='__'` is set.
**Why it happens:** pydantic-settings combines `env_prefix` + `env_nested_delimiter` + field path into env var names.
**How to avoid:** Do NOT set `env_nested_delimiter`. The auth env vars are flat fields on `MailroomSettings` (not nested), so `env_prefix` works correctly for `MAILROOM_JMAP_TOKEN`. Nested sub-models (polling, triage, etc.) are loaded from YAML only.
**Warning signs:** Auth env vars stop working; unexpected env var names required.

### Pitfall 3: YAML Source Priority vs Env Var Priority
**What goes wrong:** If YAML source is listed before env_settings in `settings_customise_sources`, env vars won't override YAML values. Or vice versa, YAML values get overridden by stale env vars left in the environment.
**Why it happens:** pydantic-settings applies sources in the order returned by `settings_customise_sources` — later sources have LOWER priority (first wins).
**How to avoid:** Return `(init_settings, env_settings, YamlConfigSettingsSource(...))` — env vars win over YAML. Since non-secret env vars are dead (clean break), env_settings will only provide the 3 auth fields. YAML provides everything else.
**Warning signs:** Auth env vars ignored, or leftover env vars override config.yaml.

### Pitfall 4: Test Migration — Config File Required
**What goes wrong:** All 188+ call sites that create `MailroomSettings()` now need a `config.yaml` file to exist. Tests that only set env vars will fail.
**Why it happens:** The new settings require YAML source. Without it, pydantic-settings either errors or gets all defaults.
**How to avoid:** Strategy options (Claude's discretion):
  - **Option A (recommended):** Create a test fixture `config.yaml` in `tests/fixtures/` and set `MAILROOM_CONFIG` env var in conftest.py. All existing tests get a valid config file via the fixture.
  - **Option B:** Pass `yaml_file` directly to `MailroomSettings` constructor or use `_env_file` pattern. Less clean.
  - **Option C:** Make config.yaml optional in test mode. Defeats the fail-fast philosophy.
**Warning signs:** Every test fails with "config.yaml not found" after the migration.

### Pitfall 5: Human Tests — load_dotenv + config.yaml
**What goes wrong:** Human tests use `load_dotenv()` to load `.env` for auth vars. After migration they also need a `config.yaml` file in the project root.
**Why it happens:** Human tests run from the project root, so `config.yaml` in the working directory (the default path) will be found automatically. But this config.yaml must exist.
**How to avoid:** Ship a `config.yaml` alongside `config.yaml.example`. The `.env.example` shrinks to 3 auth lines. Human tests load `.env` for auth + find `config.yaml` in cwd for behavior config. `.env` stays in `.gitignore`; a default `config.yaml` can be committed (no secrets).
**Warning signs:** Human tests fail with "config.yaml not found".

### Pitfall 6: Triage Category Shorthand Parsing
**What goes wrong:** PyYAML parses `- Feed` as a string, but pydantic expects a `TriageCategory` model (dict with `name` key).
**Why it happens:** YAML list items can be scalars or mappings. Without a `field_validator(mode="before")`, pydantic will reject the string.
**How to avoid:** Add a `mode="before"` validator that converts strings to `{"name": string}` dicts before pydantic model parsing.
**Warning signs:** Config validation error: "expected dict, got str" for category entries.

## Code Examples

Verified patterns from pydantic-settings documentation and codebase analysis:

### settings_customise_sources with YamlConfigSettingsSource
```python
# Source: pydantic-settings official docs (Context7, HIGH confidence)
from pydantic_settings import (
    BaseSettings,
    PydanticBaseSettingsSource,
    SettingsConfigDict,
    YamlConfigSettingsSource,
)

class MailroomSettings(BaseSettings):
    model_config = SettingsConfigDict(
        yaml_file='config.yaml',
        yaml_file_encoding='utf-8',
        env_prefix='MAILROOM_',
    )

    # flat auth fields from env vars
    jmap_token: str
    carddav_username: str = ""
    carddav_password: str = ""

    # nested sections from YAML
    polling: PollingSettings = PollingSettings()
    triage: TriageSettings = TriageSettings()
    labels: LabelSettings = LabelSettings()
    logging: LoggingSettings = LoggingSettings()

    @classmethod
    def settings_customise_sources(
        cls,
        settings_cls: type[BaseSettings],
        init_settings: PydanticBaseSettingsSource,
        env_settings: PydanticBaseSettingsSource,
        dotenv_settings: PydanticBaseSettingsSource,
        file_secret_settings: PydanticBaseSettingsSource,
    ) -> tuple[PydanticBaseSettingsSource, ...]:
        return (
            init_settings,
            env_settings,
            YamlConfigSettingsSource(settings_cls),
        )
```

### Dynamic yaml_file Path from MAILROOM_CONFIG Env Var
```python
# Pattern: override yaml_file in settings_customise_sources
import os

@classmethod
def settings_customise_sources(
    cls,
    settings_cls: type[BaseSettings],
    init_settings: PydanticBaseSettingsSource,
    env_settings: PydanticBaseSettingsSource,
    dotenv_settings: PydanticBaseSettingsSource,
    file_secret_settings: PydanticBaseSettingsSource,
) -> tuple[PydanticBaseSettingsSource, ...]:
    config_path = os.environ.get("MAILROOM_CONFIG", "config.yaml")
    return (
        init_settings,
        env_settings,
        YamlConfigSettingsSource(settings_cls, yaml_file=config_path),
    )
```

### Name-Only Category Shorthand Validator
```python
# Project-specific: allow '- Feed' YAML shorthand for triage categories
from pydantic import field_validator

class TriageSettings(BaseModel):
    categories: list[TriageCategory] = Field(default_factory=_default_categories)

    @field_validator("categories", mode="before")
    @classmethod
    def normalize_categories(cls, v: list) -> list:
        """'- Feed' → {'name': 'Feed'}; dict form passes through."""
        return [{"name": item} if isinstance(item, str) else item for item in v]
```

### Test Fixture Pattern for YAML Config
```python
# tests/conftest.py — recommended approach
import pytest
from pathlib import Path

@pytest.fixture(autouse=True)
def _set_config_path(monkeypatch, tmp_path):
    """Point MailroomSettings to a test config.yaml."""
    config = tmp_path / "config.yaml"
    config.write_text("")  # empty = all defaults
    monkeypatch.setenv("MAILROOM_CONFIG", str(config))

@pytest.fixture
def mock_settings(monkeypatch, _set_config_path):
    """Create MailroomSettings with test auth env vars + test config.yaml."""
    monkeypatch.setenv("MAILROOM_JMAP_TOKEN", "test-token")
    monkeypatch.setenv("MAILROOM_CARDDAV_USERNAME", "test@fastmail.com")
    monkeypatch.setenv("MAILROOM_CARDDAV_PASSWORD", "test-password")
    return MailroomSettings()
```

## Migration Surface Analysis

### Field Access Path Changes

| Current Path | New Path | Used In |
|-------------|----------|---------|
| `settings.jmap_token` | `settings.jmap_token` (unchanged) | __main__, provisioner, human tests |
| `settings.carddav_username` | `settings.carddav_username` (unchanged) | __main__, provisioner, human tests |
| `settings.carddav_password` | `settings.carddav_password` (unchanged) | __main__, provisioner, human tests |
| `settings.poll_interval` | `settings.polling.interval` | __main__ (3 sites) |
| `settings.debounce_seconds` | `settings.polling.debounce_seconds` | __main__ (2 sites) |
| `settings.log_level` | `settings.logging.level` | __main__, provisioner |
| `settings.label_mailroom_error` | `settings.labels.mailroom_error` | screener.py, provisioner, human tests |
| `settings.label_mailroom_warning` | `settings.labels.mailroom_warning` | screener.py, provisioner |
| `settings.warnings_enabled` | `settings.labels.warnings_enabled` | screener.py, provisioner |
| `settings.screener_mailbox` | `settings.triage.screener_mailbox` | screener.py, sieve_guidance, human tests |
| `settings.triage_categories` | `settings.triage.categories` | test_config.py |
| `settings.triage_labels` | `settings.triage_labels` (property stays on root) | __main__, screener, provisioner, human tests |
| `settings.label_to_category_mapping` | `settings.label_to_category_mapping` (property stays on root) | screener, human tests |
| `settings.required_mailboxes` | `settings.required_mailboxes` (property stays on root) | __main__, provisioner, human tests |
| `settings.contact_groups` | `settings.contact_groups` (property stays on root) | __main__, provisioner, human tests |

### Design Note on Computed Properties

The computed properties (`triage_labels`, `label_to_category_mapping`, `required_mailboxes`, `contact_groups`) should remain on the root `MailroomSettings` class. They access data from multiple sub-models (e.g., `required_mailboxes` needs `triage`, `labels`, and `screener_mailbox`). Keeping them on the root avoids cross-model references and keeps the consumer API stable.

### File Counts by Area

| Area | Files | Approx. Changes |
|------|-------|-----------------|
| `src/mailroom/` (core app) | 6 files | ~35 access path changes + config.py rewrite |
| `tests/` | 4 files | ~40 settings constructor sites + env var changes |
| `human-tests/` | 16 files | ~30 access path changes + dotenv updates |
| `k8s/` | 2 files | configmap.yaml rewrite + deployment.yaml volume mount |
| Project root | 3 files | pyproject.toml, .env.example, config.yaml.example (new) |

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `env_prefix` flat env vars | `YamlConfigSettingsSource` + env vars | pydantic-settings v2.1+ | Native YAML support, no custom parsing |
| `pydantic-yaml` (3rd party) | `pydantic-settings[yaml]` (official extra) | pydantic-settings v2.1 | Built-in, maintained by pydantic team |
| Manual `yaml.safe_load` + `BaseSettings(**dict)` | `settings_customise_sources` | pydantic-settings v2.0 | Proper source priority chain |

**Deprecated/outdated:**
- `pydantic-yaml` (NowanIlfideme/pydantic-yaml): Separate project, not needed when pydantic-settings has native support.
- `yaml-settings-pydantic`: Third-party wrapper, superseded by official `YamlConfigSettingsSource`.

## Open Questions

1. **Config file existence check — where to enforce?**
   - What we know: `MAILROOM_CONFIG` env var or default `config.yaml` in cwd.
   - What's unclear: Should the existence check happen in `settings_customise_sources` (raising `SystemExit`), in a model validator, or in the calling code (`__main__.py`, `provisioner.py`)? `YamlConfigSettingsSource` may silently skip missing files.
   - Recommendation: Check in `settings_customise_sources` or a class-level `__init_subclass__` / validator. If `YamlConfigSettingsSource` silently returns empty dict for missing file, add explicit `Path.exists()` check before constructing `YamlConfigSettingsSource`. Test this behavior.

2. **Test config isolation strategy**
   - What we know: 4 test files + conftest create `MailroomSettings()` via env vars. Need YAML source now.
   - What's unclear: Should every test use `tmp_path` for a fresh config, or share a `tests/fixtures/config.yaml`?
   - Recommendation: Use `tmp_path` with `MAILROOM_CONFIG` env var in an `autouse` conftest fixture. Write empty YAML (uses defaults) or specific YAML per test as needed. This gives isolation without shared state.

3. **Docker WORKDIR and config.yaml mount path**
   - What we know: Dockerfile `WORKDIR /app`, CMD runs `python -m mailroom`. K8s mounts config.yaml as volume.
   - What's unclear: Mount to `/app/config.yaml` (matches WORKDIR) or separate `/etc/mailroom/config.yaml` (with `MAILROOM_CONFIG` env var)?
   - Recommendation: Mount to `/app/config.yaml` — matches the default "config.yaml in cwd" behavior. No extra env var needed.

## Sources

### Primary (HIGH confidence)
- Context7 `/pydantic/pydantic-settings` — `YamlConfigSettingsSource` API, `settings_customise_sources` pattern, `SettingsConfigDict` options, nested model support
- PyPI pydantic-settings page — confirmed `[yaml]` extra exists, version 2.13.1 current
- Project codebase analysis — `src/mailroom/core/config.py`, all 22 files with `MailroomSettings` usage

### Secondary (MEDIUM confidence)
- pydantic-settings GitHub docs — `YamlConfigSettingsSource`, `JsonConfigSettingsSource` examples (verified via Context7)
- PyPI PyYAML page — version 6.0.2 (confirmed installed system-wide, not in venv)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — pydantic-settings[yaml] is the official, documented path; already partially installed
- Architecture: HIGH — source priority chain, nested models, env var behavior all verified via Context7 docs
- Pitfalls: HIGH — verified PyYAML venv absence, tested `YamlConfigSettingsSource` importability, mapped all 188 access sites
- Migration surface: HIGH — complete grep of all field access paths across 22 files

**Research date:** 2026-03-01
**Valid until:** 2026-04-01 (stable library, slow-moving domain)

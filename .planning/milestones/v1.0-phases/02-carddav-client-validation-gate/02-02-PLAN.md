---
phase: 02-carddav-client-validation-gate
plan: 02
type: tdd
wave: 2
depends_on:
  - 02-01
files_modified:
  - src/mailroom/clients/carddav.py
  - tests/test_carddav_client.py
autonomous: true
requirements:
  - CDAV-02
  - CDAV-03
  - CDAV-04
  - CDAV-05

must_haves:
  truths:
    - "Searching by email finds existing contacts matching any EMAIL property on the vCard"
    - "Creating a contact produces a valid vCard 3.0 with FN, N, EMAIL, NOTE (Added by Mailroom on DATE), and UID"
    - "Adding a contact to a group appends X-ADDRESSBOOKSERVER-MEMBER entry to the group vCard"
    - "Group update uses If-Match ETag for concurrency safety and retries on 412"
    - "Upsert flow: existing contact gets group membership without overwriting existing data"
    - "Upsert flow: new contact is created then added to group"
    - "Duplicate contacts are prevented by searching before creating"
  artifacts:
    - path: "src/mailroom/clients/carddav.py"
      provides: "search_by_email, create_contact, add_to_group, upsert_contact methods"
      exports: ["CardDAVClient"]
    - path: "tests/test_carddav_client.py"
      provides: "Unit tests for all contact operations and upsert flow"
      min_lines: 200
  key_links:
    - from: "CardDAVClient.search_by_email()"
      to: "REPORT addressbook-query"
      via: "XML request with prop-filter on EMAIL"
      pattern: "addressbook-query.*prop-filter.*EMAIL"
    - from: "CardDAVClient.create_contact()"
      to: "PUT {addressbook}/{uuid}.vcf"
      via: "vobject serialization with If-None-Match: *"
      pattern: "If-None-Match.*\\*"
    - from: "CardDAVClient.add_to_group()"
      to: "PUT group vCard"
      via: "GET group, add MEMBER line, PUT with If-Match"
      pattern: "If-Match"
    - from: "CardDAVClient.upsert_contact()"
      to: "search_by_email -> create_contact/merge -> add_to_group"
      via: "orchestration method"
      pattern: "search_by_email.*add_to_group"
---

<objective>
Implement all contact operations on the CardDAV client: search by email, create contact, add to group, and upsert orchestration with merge-cautious logic.

Purpose: These operations form the complete contact management capability needed by the triage pipeline (Phase 3). Search prevents duplicates (CDAV-05), create produces valid vCards (CDAV-03), group-add assigns routing (CDAV-04), and upsert ties them together with the merge-cautious strategy (CDAV-05).

Output: A fully functional CardDAVClient that can search, create, update, and assign contacts to groups with concurrency safety.
</objective>

<execution_context>
@/Users/flo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/flo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-carddav-client-validation-gate/02-RESEARCH.md
@.planning/phases/02-carddav-client-validation-gate/02-01-SUMMARY.md
@src/mailroom/clients/carddav.py
@tests/test_carddav_client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Search by email and create contact with TDD</name>
  <files>
    src/mailroom/clients/carddav.py
    tests/test_carddav_client.py
  </files>
  <action>
**RED phase -- search_by_email:**

1. Add failing tests:
   - `test_search_by_email_finds_contact`: Mock REPORT response with a 207 Multi-Status containing one matching vCard. Assert the method returns a list with one entry containing `href`, `etag`, and `vcard_data` keys.
   - `test_search_by_email_no_results`: Mock REPORT response with empty 207. Assert empty list returned.
   - `test_search_by_email_multiple_results`: Mock response with two contacts (same email on two different vCards). Assert both returned.
   - `test_search_not_connected_raises`: Assert RuntimeError before connect().

**GREEN phase -- search_by_email:**

2. Implement `search_by_email(self, email: str) -> list[dict]` on CardDAVClient:
   - Build a CardDAV REPORT `addressbook-query` XML body with:
     - `<D:prop><D:getetag/><C:address-data/></D:prop>`
     - `<C:filter test="anyof"><C:prop-filter name="EMAIL"><C:text-match collation="i;unicode-casemap" match-type="equals">{email}</C:text-match></C:prop-filter></C:filter>`
   - Send REPORT to `self._addressbook_url` with `Depth: 1` header.
   - Use `_parse_multistatus()` (from Plan 01) to parse the 207 response.
   - Return list of dicts with `href`, `etag`, `vcard_data`.
   - Guard: raise RuntimeError if not connected.

   **Important:** Use `xml.etree.ElementTree` to construct the XML body (not f-strings) to properly escape email addresses containing special XML characters (e.g., `&`, `<`). OR use f-string with `xml.sax.saxutils.escape()` for the email value.

**RED phase -- create_contact:**

3. Add failing tests:
   - `test_create_contact_sends_valid_vcard`: Mock PUT response (201 Created with ETag header). Assert the method sends a PUT to `{addressbook_url}/{uuid}.vcf`. Parse the sent vCard body with `vobject.readOne()` and verify: VERSION is 3.0, FN matches display_name, EMAIL matches email, NOTE contains "Added by Mailroom on", UID is a valid UUID.
   - `test_create_contact_returns_href_etag_uid`: Assert method returns a dict with `href`, `etag`, `uid` keys.
   - `test_create_contact_uses_if_none_match`: Assert the PUT request includes `If-None-Match: *` header to prevent overwriting existing contacts.
   - `test_create_contact_email_prefix_fallback`: When display_name is empty/None, assert FN is set to the email prefix (part before @).

**GREEN phase -- create_contact:**

4. Implement `create_contact(self, email: str, display_name: str | None = None) -> dict` on CardDAVClient:
   - Generate `contact_uid = str(uuid.uuid4())`.
   - Build vCard using `vobject`:
     - `card = vobject.vCard()`
     - `card.add("uid").value = contact_uid`
     - `card.add("fn").value = display_name or email.split("@")[0]` (fallback per user decision)
     - `card.add("n").value = vobject.vcard.Name(given=display_name or email.split("@")[0])`
     - `email_prop = card.add("email"); email_prop.value = email; email_prop.type_param = "INTERNET"`
     - `card.add("note").value = f"Added by Mailroom on {date.today().isoformat()}"`
   - PUT to `{self._addressbook_url}/{contact_uid}.vcf` with:
     - `Content-Type: text/vcard; charset=utf-8`
     - `If-None-Match: *`
     - Body: `card.serialize().encode("utf-8")`
   - Return `{"href": "/{contact_uid}.vcf", "etag": resp.headers.get("etag", ""), "uid": contact_uid}`.
   - Note: Build the full PUT URL from `self._addressbook_url` + `/{contact_uid}.vcf`. Store the relative href for consistency with other operations.

Run all tests. All should pass.
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run pytest tests/test_carddav_client.py -x -v</automated>
  </verify>
  <done>search_by_email finds contacts via REPORT addressbook-query with case-insensitive email matching. create_contact produces valid vCard 3.0 with proper fields and If-None-Match safety. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Group membership, merge-cautious update, and upsert orchestration with TDD</name>
  <files>
    src/mailroom/clients/carddav.py
    tests/test_carddav_client.py
  </files>
  <action>
**RED phase -- add_to_group:**

1. Add failing tests:
   - `test_add_to_group_appends_member`: Mock GET for group vCard (containing existing members), then mock PUT. Assert the PUT body contains the new `X-ADDRESSBOOKSERVER-MEMBER:urn:uuid:{contact_uid}` line AND preserves existing members.
   - `test_add_to_group_uses_if_match`: Assert PUT includes `If-Match: {etag}` header with the ETag from the GET response.
   - `test_add_to_group_retries_on_412`: Mock GET, then mock PUT returning 412 (Precondition Failed), then mock a second GET (fresh ETag), then mock a second PUT (success). Assert the method succeeds after retry. Assert exactly 2 PUTs were attempted.
   - `test_add_to_group_raises_after_max_retries`: Mock GET + PUT(412) three times. Assert the method raises after exhausting retries (3 attempts).
   - `test_add_to_group_skips_if_already_member`: Mock GET for a group vCard that already contains the contact's UID as a MEMBER. Assert no PUT is sent (contact is already in the group).

**GREEN phase -- add_to_group:**

2. Implement `add_to_group(self, group_name: str, contact_uid: str, max_retries: int = 3) -> str` on CardDAVClient:
   - Look up group info from `self._groups[group_name]` (populated by `validate_groups()` in Plan 01). Get `href` and `etag`.
   - Retry loop (up to `max_retries`):
     - GET the group vCard from `https://{self._hostname}{href}`. Parse response with `vobject.readOne()`.
     - Get current ETag from response headers.
     - Check if contact_uid is already a member: check all `x-addressbookserver-member` entries for `urn:uuid:{contact_uid}`. If already present, return early (skip PUT).
     - Add `X-ADDRESSBOOKSERVER-MEMBER` with value `urn:uuid:{contact_uid}` using `card.add("x-addressbookserver-member").value = f"urn:uuid:{contact_uid}"`.
     - PUT serialized vCard back to the same URL with:
       - `Content-Type: text/vcard; charset=utf-8`
       - `If-Match: {current_etag}` (pass ETag exactly as received, including quotes)
     - If PUT returns 412: log warning, continue retry loop.
     - If PUT succeeds: update stored ETag in `self._groups[group_name]["etag"]`, return new ETag.
   - After `max_retries` exhausted: raise `RuntimeError(f"Failed to add member to group {group_name} after {max_retries} retries (ETag conflict)")`.

**RED phase -- upsert_contact:**

3. Add failing tests:
   - `test_upsert_new_contact`: Mock search_by_email returning empty list, mock create_contact, mock add_to_group. Assert create_contact was called with correct email/display_name, add_to_group was called with the new contact's UID.
   - `test_upsert_existing_contact_adds_to_group`: Mock search_by_email returning one existing contact (with vcard_data). Mock add_to_group. Assert create_contact was NOT called. Assert add_to_group was called with the existing contact's UID.
   - `test_upsert_existing_contact_merge_cautious`: Mock search_by_email returning a contact with existing FN and NOTE but no email matching the new one. Mock PUT for update. Assert the updated vCard: preserves existing FN, preserves existing NOTE, adds new email, adds "Added by Mailroom" note only if NOTE was empty.
   - `test_upsert_existing_contact_no_overwrite`: Mock search returning contact with filled FN, N, NOTE. Assert none of these fields are overwritten.

**GREEN phase -- upsert_contact:**

4. Implement `upsert_contact(self, email: str, display_name: str | None, group_name: str) -> dict` on CardDAVClient:
   - Call `search_by_email(email)`.
   - **If no existing contact:**
     - Call `create_contact(email, display_name)` to create new contact.
     - Call `add_to_group(group_name, new_contact["uid"])`.
     - Return `{"action": "created", "uid": new_contact["uid"], "group": group_name}`.
   - **If existing contact found:**
     - Parse the existing vCard with `vobject.readOne(result["vcard_data"])`.
     - Extract the existing contact's UID from the vCard.
     - **Merge-cautious update** (per user decision):
       - Only fill empty fields. Never overwrite existing data.
       - Check if email is already present on the contact (across all EMAIL properties, case-insensitive). If not, add it.
       - Only set FN/N if currently empty or missing.
       - Only add NOTE ("Added by Mailroom on DATE") if no NOTE exists.
       - If any fields were filled: PUT the updated vCard back with `If-Match: {etag}`.
     - Call `add_to_group(group_name, contact_uid)`.
     - Return `{"action": "existing", "uid": contact_uid, "group": group_name}`.
   - If multiple contacts match the email: use the first result (deterministic behavior). Log a warning about multiple matches.

Run all tests. All should pass.

**REFACTOR phase (if needed):**

5. Review the full CardDAVClient class. Look for opportunities to reduce duplication in URL construction, ETag handling, or HTTP calls. Extract helpers if they improve readability. Run tests after any refactoring to ensure nothing breaks.
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && uv run pytest tests/test_carddav_client.py -x -v</automated>
    <manual>Review CardDAVClient class for completeness: connect, validate_groups, search_by_email, create_contact, add_to_group, upsert_contact methods all present with docstrings.</manual>
  </verify>
  <done>add_to_group modifies group vCard with ETag safety and retry on 412. upsert_contact orchestrates search-create/merge-group flow. Existing contacts are merged cautiously (no overwrites). Duplicates prevented by email search. All unit tests pass.</done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/test_carddav_client.py -x -v` -- all tests pass
2. `uv run pytest tests/ -x` -- all existing tests still pass (no regressions)
3. `uv run ruff check src/ tests/` -- no lint errors
4. CardDAVClient has: search_by_email, create_contact, add_to_group, upsert_contact
5. ETag/If-Match used on all PUT operations
6. Merge-cautious logic: empty fields filled, existing data preserved
7. Duplicate prevention: search before create
</verification>

<success_criteria>
- Contact search via REPORT addressbook-query works with case-insensitive email matching
- New contacts have valid vCard 3.0 with FN, N, EMAIL, NOTE, UID
- Group membership uses X-ADDRESSBOOKSERVER-MEMBER (not vCard 4.0 MEMBER)
- Concurrent edit protection via If-Match/412 retry
- Upsert correctly orchestrates the full flow for both new and existing contacts
- All unit tests pass with mocked httpx responses
</success_criteria>

<output>
After completion, create `.planning/phases/02-carddav-client-validation-gate/02-02-SUMMARY.md`
</output>

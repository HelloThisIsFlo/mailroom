---
phase: 02-carddav-client-validation-gate
plan: 03
type: execute
wave: 3
depends_on:
  - 02-02
files_modified:
  - human-tests/test_4_carddav_auth.py
  - human-tests/test_5_carddav_contacts.py
  - human-tests/test_6_carddav_groups.py
  - human-tests/.env.example
autonomous: false
requirements:
  - CDAV-01
  - CDAV-02
  - CDAV-03
  - CDAV-04
  - CDAV-05

must_haves:
  truths:
    - "Human test scripts exercise all CardDAV operations against live Fastmail"
    - "Test script validates: auth + discovery, contact create, contact search (no duplicates), group membership, ETag conflict handling"
    - "Setup documentation explains manual prerequisites (groups, app password)"
    - "Running the test suite confirms Phase 2 success criteria against live Fastmail"
  artifacts:
    - path: "human-tests/test_4_carddav_auth.py"
      provides: "CardDAV authentication and addressbook discovery test"
      min_lines: 20
    - path: "human-tests/test_5_carddav_contacts.py"
      provides: "Contact create, search, and duplicate prevention test"
      min_lines: 40
    - path: "human-tests/test_6_carddav_groups.py"
      provides: "Group membership, ETag conflict test with pause"
      min_lines: 50
  key_links:
    - from: "human-tests/test_4_carddav_auth.py"
      to: "CardDAVClient.connect() + validate_groups()"
      via: "direct method calls with live credentials"
      pattern: "client\\.connect|validate_groups"
    - from: "human-tests/test_6_carddav_groups.py"
      to: "CardDAVClient.add_to_group()"
      via: "input() pause for manual Fastmail edit between GET and PUT"
      pattern: "input.*press Enter"
---

<objective>
Create human test scripts that validate all CardDAV operations against live Fastmail. This is the validation gate -- Phase 2 is not complete until these scripts pass against real Fastmail data.

Purpose: The CardDAV client is built on assumptions about Fastmail's Apple-style group model, PROPFIND discovery, and REPORT query support. These assumptions come from research, not live testing. The human test scripts prove the implementation works against the real service before Phase 3 builds on top of it.

Output: Three human test scripts covering auth/discovery, contact operations, and group membership with ETag conflict testing. A checkpoint for the user to run and verify.
</objective>

<execution_context>
@/Users/flo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/flo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-carddav-client-validation-gate/02-CONTEXT.md
@.planning/phases/02-carddav-client-validation-gate/02-02-SUMMARY.md
@src/mailroom/clients/carddav.py
@human-tests/test_1_auth.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create human test scripts for CardDAV validation</name>
  <files>
    human-tests/test_4_carddav_auth.py
    human-tests/test_5_carddav_contacts.py
    human-tests/test_6_carddav_groups.py
    human-tests/.env.example
  </files>
  <action>
Follow the existing human test pattern from `test_1_auth.py`: load `.env` from the human-tests directory, import settings and clients, print clear output with PASS/FAIL indicators.

**Update `.env.example`:** Add `MAILROOM_CARDDAV_USERNAME` and `MAILROOM_CARDDAV_PASSWORD` entries (with placeholder values) if not already present.

**test_4_carddav_auth.py** -- CardDAV Authentication and Discovery (read-only, safe):
- Load settings, create CardDAVClient with `settings.carddav_username` and `settings.carddav_password`.
- Call `client.connect()`. Print the discovered addressbook URL.
- Call `client.validate_groups(settings.contact_groups)`. Print each group name with its href and UID.
- On success: print `--- PASS ---`.
- On failure: print `--- FAIL ---` with error details and setup instructions.

**test_5_carddav_contacts.py** -- Contact Create, Search, and Duplicate Prevention (MODIFIES CONTACTS):
- Print a WARNING that this test creates contacts. Ask user to confirm with `input("Press Enter to continue or Ctrl+C to cancel: ")`.
- Connect and validate groups.
- **Step 1 - Create:** Create a test contact using `create_contact(email="mailroom-test@example.com", display_name="Mailroom Test Contact")`. Print the created contact's UID and href.
- **Step 2 - Search:** Search for the test contact using `search_by_email("mailroom-test@example.com")`. Assert exactly one result. Print the found contact's details. Print `--- STEP 2 PASS ---`.
- **Step 3 - Duplicate prevention:** Call `search_by_email("mailroom-test@example.com")` again. Assert still exactly one result (not two). Then call `upsert_contact("mailroom-test@example.com", "Mailroom Test Contact", settings.contact_groups[0])`. Search again -- assert still one result. Print `--- STEP 3 PASS ---`.
- **Step 4 - Verify in Fastmail:** Print `"Now check Fastmail Contacts -- you should see 'Mailroom Test Contact' with email mailroom-test@example.com"`. Wait for user confirmation: `input("Verified in Fastmail? Press Enter to continue or type 'fail': ")`.
- **Cleanup:** Print instructions to manually delete the test contact from Fastmail (don't auto-delete -- user should verify it exists first).
- On overall success: print `--- PASS ---`.

**test_6_carddav_groups.py** -- Group Membership and ETag Conflict (MODIFIES CONTACTS AND GROUPS):
- Print a WARNING that this test modifies groups. Ask user to confirm.
- Connect and validate groups.
- **Step 1 - Create test contact:** Create a fresh test contact (`mailroom-group-test@example.com`).
- **Step 2 - Add to group:** Use `add_to_group(settings.contact_groups[0], contact_uid)` (first group, typically "Imbox"). Print success. Verify: search by email, parse the group vCard from validate_groups result, confirm the UID appears as a MEMBER.
- **Step 3 - Verify in Fastmail:** Print `"Check Fastmail Contacts: the test contact should appear in the {group_name} group"`. Wait for user confirmation.
- **Step 4 - ETag conflict test (deterministic, per user decision):**
  - Call `add_to_group` for a different group, but PAUSE between the internal GET and PUT:
    - Actually, since add_to_group is atomic, create the conflict externally:
    - Instead: Fetch the group vCard manually (GET), print the current ETag, then tell the user: `"Now edit the {group_name} group in Fastmail (add or remove any contact). Then press Enter."` Wait for `input()`.
    - After user edits, attempt `add_to_group()`. It should internally GET the fresh vCard (with new ETag), add the member, and PUT successfully. If the first PUT gets 412, the retry should succeed.
    - Print whether retry was triggered (success either way confirms the ETag handling works).
  - Print `--- STEP 4 PASS ---`.
- **Cleanup:** Print instructions to manually delete test contacts and remove them from groups.
- On overall success: print `--- PASS ---`.

**Important:** Follow the existing pattern exactly: `load_dotenv(Path(__file__).parent / ".env")`, import settings after dotenv, use `sys.exit(1)` on failure. Each script is standalone and runnable independently.
  </action>
  <verify>
    <automated>cd /Users/flo/Work/Private/Dev/Services/mailroom && python -c "import ast; [ast.parse(open(f'human-tests/{f}').read()) for f in ['test_4_carddav_auth.py', 'test_5_carddav_contacts.py', 'test_6_carddav_groups.py']]" && echo "All scripts parse OK"</automated>
    <manual>Run each test script against live Fastmail: `cd human-tests && uv run python test_4_carddav_auth.py` then test_5 then test_6</manual>
  </verify>
  <done>Three human test scripts created, syntactically valid, follow existing test pattern, cover all Phase 2 success criteria.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Validate CardDAV client against live Fastmail</name>
  <files>human-tests/test_4_carddav_auth.py, human-tests/test_5_carddav_contacts.py, human-tests/test_6_carddav_groups.py</files>
  <action>
Human verification checkpoint. Complete CardDAV client with unit tests and human validation scripts has been built. The client can authenticate, discover the address book, search/create/update contacts, and manage group membership with ETag concurrency safety.

The user must run the human test scripts against live Fastmail to validate Phase 2.

Steps for the user:
1. Set up prerequisites in Fastmail (if not already done):
   - Create an app password for CardDAV access
   - Ensure contact groups exist: Imbox, Feed, Paper Trail, Jail
   - Set MAILROOM_CARDDAV_USERNAME and MAILROOM_CARDDAV_PASSWORD in human-tests/.env

2. Run auth test: `cd human-tests && uv run python test_4_carddav_auth.py`
   Expected: Prints addressbook URL and all 4 groups with hrefs

3. Run contacts test: `cd human-tests && uv run python test_5_carddav_contacts.py`
   Expected: Creates test contact, finds it via search, prevents duplicate

4. Run groups test: `cd human-tests && uv run python test_6_carddav_groups.py`
   Expected: Adds contact to group, handles ETag conflict via retry

5. Clean up test contacts from Fastmail

Resume signal: Type "approved" if all 3 test scripts passed, or describe any failures.
  </action>
  <verify>User confirms all 3 human test scripts passed against live Fastmail</verify>
  <done>Phase 2 validation gate passed: CardDAV client works against live Fastmail for auth, contact operations, and group membership with ETag safety.</done>
</task>

</tasks>

<verification>
1. All 3 human test scripts exist and parse without syntax errors
2. Scripts follow the existing human-tests pattern (dotenv, settings, PASS/FAIL)
3. .env.example updated with CardDAV credentials
4. User runs all 3 scripts against live Fastmail and confirms PASS
</verification>

<success_criteria>
- test_4: CardDAV auth succeeds, addressbook discovered, all 4 groups validated
- test_5: Contact created with correct vCard fields, search finds it, no duplicates after re-run
- test_6: Group membership works, ETag conflict test passes (retry on 412 or first-try success)
- User confirms Phase 2 validation gate is PASSED
</success_criteria>

<output>
After completion, create `.planning/phases/02-carddav-client-validation-gate/02-03-SUMMARY.md`
</output>

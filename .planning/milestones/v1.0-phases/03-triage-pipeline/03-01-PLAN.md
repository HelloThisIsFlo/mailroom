---
phase: 03-triage-pipeline
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/mailroom/core/config.py
  - src/mailroom/workflows/__init__.py
  - src/mailroom/workflows/screener.py
  - tests/test_screener_workflow.py
  - tests/conftest.py
autonomous: true
requirements:
  - TRIAGE-01
  - TRIAGE-06

must_haves:
  truths:
    - "Workflow collects triaged emails across all four triage labels in a single poll cycle"
    - "Emails from the same sender with different triage labels are detected as conflicts"
    - "Conflicted emails receive @MailroomError label without removing triage labels"
    - "Emails already marked with @MailroomError are skipped on subsequent polls"
    - "Transient failures during conflict handling leave triage labels in place for retry"
  artifacts:
    - path: "src/mailroom/workflows/screener.py"
      provides: "ScreenerWorkflow class with poll cycle and conflict detection"
      exports: ["ScreenerWorkflow"]
    - path: "src/mailroom/core/config.py"
      provides: "Updated config with destination_mailbox in mapping and screener_mailbox setting"
      contains: "screener_mailbox"
    - path: "tests/test_screener_workflow.py"
      provides: "TDD tests for poll cycle, conflict detection, error labeling, and skip filtering"
      min_lines: 100
  key_links:
    - from: "src/mailroom/workflows/screener.py"
      to: "src/mailroom/clients/jmap.py"
      via: "JMAPClient.query_emails, get_email_senders, call (for error label)"
      pattern: "self\\._jmap\\.(query_emails|get_email_senders|call)"
    - from: "src/mailroom/workflows/screener.py"
      to: "src/mailroom/core/config.py"
      via: "MailroomSettings.triage_labels, label_to_group_mapping, label_mailroom_error"
      pattern: "self\\._settings\\.(triage_labels|label_to_group_mapping|label_mailroom_error)"
---

<objective>
Build the ScreenerWorkflow class with the poll cycle orchestration: collect triaged emails across all labels, group by sender, detect conflicting triage labels, apply @MailroomError to conflicts, filter out already-errored emails, and set up the per-sender processing boundary with try/except for retry safety.

Purpose: Establishes the workflow skeleton that Plan 02 fills with per-sender processing logic. The conflict detection and error labeling are the most correctness-critical parts of the pipeline -- they must fire BEFORE any mutations (contact upsert, email moves).

Output: Working ScreenerWorkflow class (sans _process_sender body), updated config with destination mapping, comprehensive TDD tests.
</objective>

<execution_context>
@/Users/flo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/flo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-triage-pipeline/03-CONTEXT.md
@.planning/phases/03-triage-pipeline/03-RESEARCH.md
@src/mailroom/core/config.py
@src/mailroom/clients/jmap.py
@src/mailroom/clients/carddav.py
@src/mailroom/workflows/__init__.py
@tests/conftest.py
@tests/test_config.py
</context>

<feature>
  <name>ScreenerWorkflow poll cycle with conflict detection</name>
  <files>
    src/mailroom/core/config.py
    src/mailroom/workflows/__init__.py
    src/mailroom/workflows/screener.py
    tests/test_screener_workflow.py
    tests/conftest.py
  </files>
  <behavior>
    The ScreenerWorkflow class orchestrates one poll cycle of the triage pipeline.

    **Config changes (src/mailroom/core/config.py):**
    - Add `screener_mailbox: str = "Screener"` setting for configurable Screener mailbox name
    - Update `label_to_group_mapping` property: add `destination_mailbox` key to each entry.
      For Imbox: `"destination_mailbox": "Inbox"` (swept emails go to Inbox).
      For Feed: `"destination_mailbox": "Feed"`.
      For Paper Trail: `"destination_mailbox": "Paper Trail"`.
      For Jail: `"destination_mailbox": "Jail"`.
    - The existing `destination` field (which equals group name) stays unchanged for backward compat.

    **Workflow class (src/mailroom/workflows/screener.py):**

    Constructor: `__init__(self, jmap: JMAPClient, carddav: CardDAVClient, settings: MailroomSettings, mailbox_ids: dict[str, str])`
    - `mailbox_ids` is pre-resolved at startup (by caller) and contains IDs for: Inbox, Screener, Feed, Paper Trail, Jail, all 4 triage labels, @MailroomError
    - Store structlog logger bound with `component="screener"`

    `poll(self) -> int`:
    - Step 1: Call `_collect_triaged()` to get all triaged emails grouped by sender
    - Step 2: If empty, log debug and return 0
    - Step 3: Call `_detect_conflicts(triaged)` to split into clean and conflicted
    - Step 4: For each conflicted sender, call `_apply_error_label(sender, emails)`
    - Step 5: For each clean sender, call `_process_sender(sender, emails)` wrapped in try/except Exception. On exception, log warning with sender and error, leave triage labels (retry safety per TRIAGE-06).
    - Step 6: Log info summary and return count of successfully processed senders

    `_collect_triaged(self) -> dict[str, list[tuple[str, str]]]`:
    - Iterate all `self._settings.triage_labels`
    - For each label: get its mailbox ID from `self._mailbox_ids`, call `self._jmap.query_emails(label_id)` to get email IDs
    - If no emails for this label, skip
    - Call `self._jmap.get_email_senders(email_ids)` to get sender addresses
    - For emails without a sender (missing from get_email_senders result), log a warning and skip them
    - Group results as `{sender: [(email_id, label_name), ...]}`
    - After collecting all labels: filter out emails that already have @MailroomError label.
      Do this by: collecting ALL triaged email IDs, calling `self._jmap.call()` with `Email/get` requesting `["id", "mailboxIds"]`, then excluding any email_id where the @MailroomError mailbox ID is present in its mailboxIds.
    - Return the filtered dict

    `_detect_conflicts(self, triaged: dict[str, list[tuple[str, str]]]) -> tuple[dict, dict]`:
    - For each sender: collect unique label names from their emails
    - If sender has >1 distinct label: add to conflicted dict
    - Otherwise: add to clean dict
    - Return (clean, conflicted)

    `_apply_error_label(self, sender: str, emails: list[tuple[str, str]]) -> None`:
    - Get the @MailroomError mailbox ID from `self._mailbox_ids[self._settings.label_mailroom_error]`
    - For each email_id in emails: call `self._jmap.call()` with `Email/set` using patch syntax `{f"mailboxIds/{error_id}": True}` to ADD the error label without removing anything
    - Log warning with sender, conflicting labels, and count of affected emails
    - Wrap in try/except -- if error label application fails (transient), log error but continue (do not crash the poll cycle)

    `_process_sender(self, sender: str, emails: list[tuple[str, str]]) -> None`:
    - Stub in this plan: `raise NotImplementedError("Plan 02 implements per-sender processing")`
    - Plan 02 will fill this in

    Test cases (input -> expected output):
    - No triaged emails -> poll() returns 0, no client calls beyond query_emails
    - 1 sender, 1 label, 1 email -> clean sender processed, poll() returns 1 (or 0 if _process_sender is stub)
    - 1 sender, 2 different labels on 2 emails -> conflicted, @MailroomError applied to both emails, poll() returns 0
    - 2 senders, each with 1 label -> both clean, both processed
    - 1 sender in clean + 1 sender conflicted -> clean sender processed, conflicted gets error label
    - Email already has @MailroomError -> filtered out of collection, not re-processed
    - Sender has email without From header -> email skipped with warning, other emails from same sender still processed
    - _apply_error_label fails (transient) -> logged, poll continues with remaining senders
    - _process_sender raises exception -> logged, triage labels left in place, poll continues
  </behavior>
  <implementation>
    TDD: Write tests first with mocked JMAPClient and CardDAVClient (use unittest.mock.MagicMock or create simple stub classes in conftest.py). Tests define the expected call sequences and return values. Then implement the workflow to make tests pass.

    For conftest.py: Add shared fixtures:
    - `mock_settings` fixture that creates MailroomSettings with monkeypatch env vars
    - `mock_mailbox_ids` fixture with a dict of all required mailbox name->ID mappings
    - Keep these minimal; test-specific setup stays in the test file

    For the @MailroomError filtering: use a single Email/get call with all collected email IDs, check mailboxIds dict for the error label ID.

    Use structlog.get_logger() with bind() for per-sender context, matching the existing logging pattern from Phases 1 and 2.
  </implementation>
</feature>

<verification>
pytest tests/test_screener_workflow.py -x -v
pytest tests/test_config.py -x -v
</verification>

<success_criteria>
- ScreenerWorkflow.poll() collects emails across all 4 triage labels and groups by sender
- Conflicting triage labels (same sender, different labels) are detected pre-mutation
- @MailroomError is applied additively (no label removal) to conflicted emails
- Already-errored emails are filtered out of collection
- Transient failures in _apply_error_label do not crash the poll cycle
- Exception in _process_sender leaves triage labels in place (TRIAGE-06 retry safety)
- Config has screener_mailbox setting and destination_mailbox in label_to_group_mapping
- All tests pass with mocked clients (no network calls)
</success_criteria>

<output>
After completion, create `.planning/phases/03-triage-pipeline/03-01-SUMMARY.md`
</output>

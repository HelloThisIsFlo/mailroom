---
phase: 03-triage-pipeline
plan: 02
type: tdd
wave: 2
depends_on:
  - 03-01
files_modified:
  - src/mailroom/workflows/screener.py
  - tests/test_screener_workflow.py
autonomous: true
requirements:
  - TRIAGE-02
  - TRIAGE-03
  - TRIAGE-04
  - TRIAGE-05

must_haves:
  truths:
    - "For each triaged sender: contact is upserted into the correct group via CardDAV"
    - "After contact upsert: all Screener emails from that sender are swept to the destination mailbox"
    - "Imbox destination adds Inbox label to swept emails so they appear in the user's inbox"
    - "Feed, Paper Trail, and Jail destinations move emails to their mailbox without Inbox label"
    - "Triage label is removed only AFTER contact upsert and sweep succeed (last step)"
    - "Re-processing the same email does not create duplicate contacts (idempotent)"
    - "Sender already in a different contact group triggers @MailroomError instead of processing"
  artifacts:
    - path: "src/mailroom/workflows/screener.py"
      provides: "Complete _process_sender pipeline with upsert, sweep, relabel, already-grouped check"
      contains: "_process_sender"
    - path: "tests/test_screener_workflow.py"
      provides: "TDD tests for per-sender processing, destination mapping, idempotency, already-grouped detection"
      min_lines: 200
  key_links:
    - from: "src/mailroom/workflows/screener.py"
      to: "src/mailroom/clients/carddav.py"
      via: "CardDAVClient.upsert_contact for contact creation/update and group assignment"
      pattern: "self\\._carddav\\.upsert_contact"
    - from: "src/mailroom/workflows/screener.py"
      to: "src/mailroom/clients/jmap.py"
      via: "JMAPClient.query_emails (sweep), batch_move_emails (move), remove_label (cleanup)"
      pattern: "self\\._jmap\\.(query_emails|batch_move_emails|remove_label)"
    - from: "src/mailroom/workflows/screener.py"
      to: "src/mailroom/core/config.py"
      via: "label_to_group_mapping for destination_mailbox and group name resolution"
      pattern: "self\\._settings\\.label_to_group_mapping"
---

<objective>
Implement the per-sender processing pipeline: upsert contact into group, sweep all Screener emails to destination, handle Imbox's special Inbox relabeling, remove triage label as the final step, detect already-grouped senders, and ensure idempotent processing.

Purpose: This is the core triage logic -- the sequence that transforms a user's label tap into a fully triaged sender. The strict step ordering (upsert -> sweep -> remove label) guarantees retry safety. The already-grouped check prevents accidental group reassignment.

Output: Complete ScreenerWorkflow with all methods implemented, comprehensive TDD tests covering all destination types and edge cases.
</objective>

<execution_context>
@/Users/flo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/flo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-triage-pipeline/03-CONTEXT.md
@.planning/phases/03-triage-pipeline/03-RESEARCH.md
@.planning/phases/03-triage-pipeline/03-01-SUMMARY.md
@src/mailroom/core/config.py
@src/mailroom/clients/jmap.py
@src/mailroom/clients/carddav.py
@src/mailroom/workflows/screener.py
@tests/test_screener_workflow.py
</context>

<feature>
  <name>Per-sender triage processing pipeline</name>
  <files>
    src/mailroom/workflows/screener.py
    tests/test_screener_workflow.py
  </files>
  <behavior>
    Replace the `_process_sender` stub with the full implementation and add the `_get_destination_mailbox_ids` helper. Also add `_check_already_grouped` to detect senders already in a different contact group.

    **`_process_sender(self, sender: str, emails: list[tuple[str, str]]) -> None`:**

    Steps execute in strict order. If any step fails, the exception propagates and the triage label is NOT removed (retry on next poll per TRIAGE-06).

    1. Extract the label_name from emails (all have the same label -- conflict-free senders only reach here).
    2. Extract email_ids list from the emails tuples.
    3. Look up the group_name via `self._settings.label_to_group_mapping[label_name]["group"]`.
    4. Bind structlog context: sender, label, group.
    5. **Already-grouped check:** Call `self._check_already_grouped(sender, group_name)`. If the sender is already in a DIFFERENT group, apply @MailroomError to all their emails and return early (do NOT process). If sender is in the SAME group, proceed normally (idempotent -- TRIAGE-05).
    6. **Upsert contact (TRIAGE-02):** Call `self._carddav.upsert_contact(sender, None, group_name)`. Log the result (action: "created" or "existing", uid). Pass `None` for display_name per existing pattern (CardDAV client falls back to email prefix).
    7. **Sweep Screener emails (TRIAGE-03):** Call `self._jmap.query_emails(screener_id, sender=sender)` to find ALL emails from this sender in Screener. Per user decision: always execute the sweep query even if only the triggering email exists.
    8. **Move swept emails to destination (TRIAGE-03 + TRIAGE-04):** If sender_emails is not empty, call `self._jmap.batch_move_emails(sender_emails, screener_id, add_mailbox_ids)` where `add_mailbox_ids = self._get_destination_mailbox_ids(label_name)`. This removes Screener label and adds destination label(s). Log the count of swept emails.
    9. **Remove triage label -- LAST STEP (TRIAGE-02 + TRIAGE-06):** For each email_id in the original triggering emails (not all swept emails -- only the ones that had the triage label), call `self._jmap.remove_label(email_id, label_id)` where label_id is the triage label's mailbox ID.
    10. Log triage_complete with sender, emails_moved count.

    **`_get_destination_mailbox_ids(self, label_name: str) -> list[str]`:**

    Returns the list of mailbox IDs to add when sweeping for this label's destination.
    - Look up `self._settings.label_to_group_mapping[label_name]["destination_mailbox"]` to get the Fastmail mailbox name.
    - Return `[self._mailbox_ids[destination_mailbox_name]]`.
    - For Imbox: destination_mailbox is "Inbox", so returns [inbox_id]. Swept emails get Inbox label (appear immediately).
    - For Feed/Paper Trail/Jail: destination_mailbox matches the mailbox name, returns [feed_id] / [paper_trail_id] / [jail_id].
    - Note: per research, `batch_move_emails` removes `screener_id` and adds these IDs. The caller (step 8) passes `screener_id` as `remove_mailbox_id`.

    **`_check_already_grouped(self, sender: str, target_group: str) -> str | None`:**

    Check if sender is already a member of a contact group different from the target.
    - Call `self._carddav.search_by_email(sender)` to find the contact.
    - If no contact found: return None (new sender, safe to proceed).
    - If contact found: extract the contact's UID from the vCard data.
    - Check the contact's UID against all groups stored in `self._carddav._groups` (the validated groups dict from startup). For each group, GET the group vCard, parse X-ADDRESSBOOKSERVER-MEMBER entries, check if this contact's UID is a member.
    - Actually, this is expensive (GET per group). Better approach: The `_groups` dict from `validate_groups()` only has href/etag/uid. We need a method to check membership.
    - **Simpler approach per research recommendation (Pitfall 5):** During _process_sender, after finding the contact via search, check group membership inline. Iterate over `self._carddav._groups` keys (group names). For each group that is NOT the target group, GET the group vCard, parse members, check for contact UID. If found in a non-target group, return that group name (conflict). If not found in any non-target group (or found in target group), return None (safe).
    - This adds CardDAV overhead only for EXISTING contacts being re-triaged (rare per user decision). New contacts skip this check (no search results).
    - On transient CardDAV failure during this check: let the exception propagate up to _process_sender's try/except boundary (retry on next poll per TRIAGE-06).

    Test cases (input -> expected output):

    **Destination mapping:**
    - @ToImbox label -> batch_move_emails called with add_mailbox_ids=[inbox_id]
    - @ToFeed label -> batch_move_emails called with add_mailbox_ids=[feed_id]
    - @ToPaperTrail label -> batch_move_emails called with add_mailbox_ids=[paper_trail_id]
    - @ToJail label -> batch_move_emails called with add_mailbox_ids=[jail_id]

    **Per-sender processing:**
    - New sender (not in contacts) with @ToImbox: upsert_contact creates contact, sweep finds 3 emails, batch_move_emails called with screener_id removed and inbox_id added, triage label removed last
    - Existing sender (already a contact) with @ToFeed: upsert_contact returns "existing", sweep moves emails to Feed, triage label removed
    - Sender with only the triggering email in Screener: sweep query returns 1 email, batch_move_emails still called (per user decision: always sweep)
    - Sender with 10 emails in Screener (5 with triage label, 5 without): all 10 swept, but only the 5 with triage labels get remove_label calls

    **Idempotency (TRIAGE-05):**
    - Same email re-processed (e.g., after restart): upsert_contact returns "existing" (search finds contact), add_to_group skips (already member), batch_move_emails is idempotent (adding labels already present), remove_label removes label again (already absent = no-op or error -- handle gracefully)

    **Already-grouped sender:**
    - Sender already in "Feed" group, triaged to @ToImbox: _check_already_grouped returns "Feed", @MailroomError applied, processing stops
    - Sender already in "Imbox" group, triaged to @ToImbox again: _check_already_grouped returns None (same group = safe), processing continues normally

    **Error handling:**
    - CardDAV failure during upsert: exception propagates, triage label NOT removed (retry safe)
    - JMAP failure during sweep: exception propagates, triage label NOT removed
    - JMAP failure during remove_label: exception propagates (partially processed -- contact upserted, emails swept, but label remains = re-processing on next poll is idempotent per TRIAGE-05)
  </behavior>
  <implementation>
    TDD: Write tests first using the same mock patterns established in Plan 01. Mock both JMAPClient and CardDAVClient. Test the exact call sequence (upsert before sweep before remove_label). Use `mock.call_args_list` or ordered mock assertions to verify step ordering.

    For `_check_already_grouped`: Mock `self._carddav.search_by_email()` return value and the group vCard GET responses. Use the existing `_groups` dict structure from CardDAVClient.

    For remove_label on already-removed labels: If JMAPClient.remove_label raises RuntimeError for an already-absent label, catch it specifically in _process_sender or let the idempotent test verify that JMAP patch syntax handles this gracefully (setting `mailboxIds/x: null` when already absent should be a no-op per JMAP spec).

    Important: The already-grouped check requires accessing CardDAVClient._groups (internal dict). Since ScreenerWorkflow takes the CardDAV client as a dependency, it can access this. Alternatively, add a public method `get_group_names()` to CardDAVClient that returns the list of validated group names. For checking membership, the workflow needs to GET group vCards -- this can use the existing httpx client on the CardDAVClient. Consider adding a `check_membership(contact_uid, exclude_group: str) -> str | None` method to CardDAVClient that checks all validated groups except the target one. This keeps protocol logic in the client.

    Per the research anti-pattern: do NOT check already-grouped in the pre-mutation conflict detection gate. Check it during per-sender processing where transient failures are handled by retry.
  </implementation>
</feature>

<verification>
pytest tests/test_screener_workflow.py -x -v
pytest tests/ -x -v
</verification>

<success_criteria>
- _process_sender executes steps in strict order: already-grouped check -> upsert contact -> sweep emails -> remove triage label
- Imbox destination adds Inbox label to swept emails
- Feed/Paper Trail/Jail destinations add their respective mailbox labels
- Triage label is removed ONLY as the last step
- Already-grouped sender in a different group triggers @MailroomError
- Already-grouped sender in the same group processes normally (idempotent)
- Re-processing an email does not create duplicate contacts
- Transient CardDAV/JMAP failures leave triage labels in place
- All 4 destination types tested and verified
- All tests pass with mocked clients
</success_criteria>

<output>
After completion, create `.planning/phases/03-triage-pipeline/03-02-SUMMARY.md`
</output>
